(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\'conference--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \'',2:'\'\'+T.c(\'feature-conference\', c.c)+\'\''};module.exports=function(c){var c={c:c,p:0};return'<div class="c-application-conference '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+' "> '+T.s(s,c,v,'conference', s[2])+'</div> '}
},{"icebrace-runtime":"icebrace-runtime"}],2:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' \'+T.e(c,v,\'.\')+\' \'',1:'\' style="transform: rotate(\'+T.e(c,v,\'.\')+\')" \''};module.exports=function(c){var c={c:c,p:0};return'<svg class=" c-icon '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'class_name', s[0])+' " '+T.s(s,c,v,'rotate', s[1])+' data-type="'+T.e(c,v,'type')+'"><use xlink:href="./svg/'+T.e(c,v,'set')+'.symbol.svg#'+T.e(c,v,'type')+'"></use></svg> '}
},{"icebrace-runtime":"icebrace-runtime"}],3:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' \'+T.e(c,v,\'.\')+\' \'',1:'\' id="\'+T.e(c,v,\'.\')+\'" \'',2:'\' type="\'+T.e(c,v,\'.\')+\'" \'',3:'\' accept="\'+T.e(c,v,\'.\')+\'" \'',4:'\' name="\'+T.e(c,v,\'.\')+\'" \'',5:'\' value="\'+T.e(c,v,\'.\')+\'" \'',6:'\' placeholder="\'+T.e(c,v,\'.\')+\'" \'',7:'\' autocomplete="\'+T.e(c,v,\'.\')+\'" \'',8:'\' min="\'+T.e(c,v,\'.\')+\'" \'',9:'\' max="\'+T.e(c,v,\'.\')+\'" \'',10:'\' minlength="\'+T.e(c,v,\'.\')+\'" \'',11:'\' maxlength="\'+T.e(c,v,\'.\')+\'" \'',12:'\' multiple \'',13:'\' readonly \'',14:'\' checked \'',15:'\' disabled \'',16:'\' required \''};module.exports=function(c){var c={c:c,p:0};return'<input class=" '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'class_name', s[0])+' " '+T.s(s,c,v,'id', s[1])+' '+T.s(s,c,v,'type', s[2])+' '+T.s(s,c,v,'accept', s[3])+' '+T.s(s,c,v,'name', s[4])+' '+T.s(s,c,v,'value', s[5])+' '+T.s(s,c,v,'placeholder', s[6])+' '+T.s(s,c,v,'autocomplete', s[7])+' '+T.s(s,c,v,'min', s[8])+' '+T.s(s,c,v,'max', s[9])+' '+T.s(s,c,v,'minlength', s[10])+' '+T.s(s,c,v,'maxlength', s[11])+' '+T.s(s,c,v,'multiple', s[12])+' '+T.s(s,c,v,'readonly', s[13])+' '+T.s(s,c,v,'checked', s[14])+' '+T.s(s,c,v,'disabled', s[15])+' '+T.s(s,c,v,'required', s[16])+' > '}
},{"icebrace-runtime":"icebrace-runtime"}],4:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' \'+T.e(c,v,\'.\')+\' \'',1:'\' for="\'+T.e(c,v,\'.\')+\'" \'',2:'\'\'+T.e(c,v,\'.\')+\'\''};module.exports=function(c){var c={c:c,p:0};return'<label class=" c-label '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'class_name', s[0])+' " '+T.s(s,c,v,'for_id', s[1])+' >'+T.s(s,c,v,'text', s[2])+'</label> '}
},{"icebrace-runtime":"icebrace-runtime"}],5:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' c-loader--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \''};module.exports=function(c){var c={c:c,p:0};return'<div class=" c-loader '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+' "></div> '}
},{"icebrace-runtime":"icebrace-runtime"}],6:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\'\'+T.c(\'basic-icon: c-text__icon\', c.c)+\'\''};module.exports=function(c){var c={c:c,p:0};return'<span class=" c-text '+T.e(c,v,'styleModifier')+' "> '+T.s(s,c,v,'icon', s[0])+' <span class="c-text__text">'+T.e(c,v,'text')+'</span></span> '}
},{"icebrace-runtime":"icebrace-runtime"}],7:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' c-avatar--image \'',1:'\' c-avatar--letter \'',2:'\' \'+T.e(c,v,\'.\')+\' \'',3:'\' c-avatar--\'+T.e(c,v,\'.\')+\' \'',4:'\' style="background-image: url(\\\'\'+T.e(c,v,\'image\')+\'\\\')" \'',5:'\' data-\'+T.e(c,v,\'tag\')+\'="\'+T.e(c,v,\'value\')+\'" \'',6:'\' \'+T.s(s,c,v,\'data\', s[5])+\' \'',7:'\'\'+T.e(c,v,\'letter\')+\'\'',8:'\'\'+T.c(\'basic-icon: c-avatar__edit\', c.c)+\'\''};module.exports=function(c){var c={c:c,p:0};return'<div class=" c-avatar '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'image', s[0])+' '+T.i(s,c,v,'image', s[1])+' '+T.s(s,c,v,'class_name', s[2])+' '+T.s(s,c,v,'mod', s[3])+' " '+T.s(s,c,v,'image', s[4])+' '+T.i(s,c,v,'image', s[6])+'> '+T.i(s,c,v,'image', s[7])+' '+T.s(s,c,v,'edit', s[8])+'</div> '}
},{"icebrace-runtime":"icebrace-runtime"}],8:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' c-button--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \'',2:'\' type="button" \'',3:'\' type="\'+T.e(c,v,\'.\')+\'" \'',4:'\' disabled \'',5:'\' form="\'+T.e(c,v,\'.\')+\'" \'',6:'\'\'+T.c(\'basic-icon: c-button__icon c-button__prefix-icon\', c.c)+\'\'',7:'\' <span class="c-button__text">\'+T.e(c,v,\'.\')+\'</span> \'',8:'\'\'+T.c(\'basic-icon: c-button__icon c-button__suffix-icon\', c.c)+\'\''};module.exports=function(c){var c={c:c,p:0};return'<button class=" c-button '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+' " '+T.i(s,c,v,'type', s[2])+' '+T.s(s,c,v,'type', s[3])+' '+T.s(s,c,v,'disabled', s[4])+' '+T.s(s,c,v,'form', s[5])+' '+T.u(c,v,'hook')+' > '+T.s(s,c,v,'prefix_icon', s[6])+' '+T.s(s,c,v,'text', s[7])+' '+T.s(s,c,v,'suffix_icon', s[8])+'</button> '}
},{"icebrace-runtime":"icebrace-runtime"}],9:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\'c-icon-document--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \'',2:'\'\'+T.c(\'basic-icon\', c.c)+\'\'',3:'\'\'+T.c(\'component-icon-document\', c.c)+\'\''};module.exports=function(c){var c={c:c,p:0};return'<div class=" c-icon-document '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+' "> '+T.s(s,c,v,'icon', s[2])+''+T.s(s,c,v,'locked', s[3])+'</div> '}
},{"icebrace-runtime":"icebrace-runtime"}],10:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' c-input--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \'',2:'\'\'+T.c(\'basic-label: c-input__label\', c.c)+\'\'',3:'\'\'+T.c(\'component-button: c-input__button\', c.c)+\'\'',4:'\'\'+T.c(\'component-input__wrap\', c.c)+\'\'',5:'\'\'+T.c(\'basic-input: c-input__element\', c.c)+\'\'',6:'\'\'+T.s(s,c,v,\'element\', s[5])+\'\'',7:'\'\'+T.c(\'basic-text: c-input__desc\', c.c)+\'\''};module.exports=function(c){var c={c:c,p:0};return'<div class=" c-input '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+' "> '+T.s(s,c,v,'label', s[2])+''+T.s(s,c,v,'contextual_button', s[3])+''+T.s(s,c,v,'wrap', s[4])+' '+T.i(s,c,v,'wrap', s[6])+' '+T.s(s,c,v,'desc', s[7])+'</div> '}
},{"icebrace-runtime":"icebrace-runtime"}],11:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\'c-message-document--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \'',2:'\' <p class="c-message-document__filemsg c-message-document__filemsg--\'+T.e(c,v,\'type\')+\'">\'+T.u(c,v,\'.\')+\'</p> \'',3:'\' <p class="c-message-document__docsmsg">\'+T.e(c,v,\'.\')+\'</p> \''};module.exports=function(c){var c={c:c,p:0};return'<div class="c-message-document '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+'"> '+T.s(s,c,v,'fileinfo', s[2])+''+T.s(s,c,v,'docmsg', s[3])+'</div> '}
},{"icebrace-runtime":"icebrace-runtime"}],12:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\'c-feature-conference--\'+T.e(c,v,\'.\')+\' \'',1:'\' \'+T.e(c,v,\'.\')+\' \'',2:'\'\'+T.c(\'component-icon-document\', c.c)+\'\'',3:'\'\'+T.c(\'component-message-document\', c.c)+\'\'',4:'\'\'+T.c(\'component-avatar\', c.c)+\'\'',5:'\' <div class="c-feature-conference__activity"> \'+T.s(s,c,v,\'avatar\', s[4])+\' <div class="text">\'+T.u(c,v,\'.\')+\'</div></div> \'',6:'\'\'+T.c(\'component-input\', c.c)+\'\'',7:'\'\'+T.c(\'component-button\', c.c)+\'\'',8:'\' <img src="\'+T.e(c,v,\'.\')+\'" class="c-feature-conference__image"> \''};module.exports=function(c){var c={c:c,p:0};return'<div class="c-feature-conference '+T.e(c,v,'styleModifier')+' '+T.s(s,c,v,'mod', s[0])+' '+T.s(s,c,v,'class_name', s[1])+' "> '+T.s(s,c,v,'icon', s[2])+''+T.s(s,c,v,'message', s[3])+''+T.s(s,c,v,'activity', s[5])+''+T.s(s,c,v,'input', s[6])+' <div class="c-feature-conference__buttons"> '+T.s(s,c,v,'button', s[7])+' </div> '+T.s(s,c,v,'image', s[8])+'</div> '}
},{"icebrace-runtime":"icebrace-runtime"}],13:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\' <!--[if lte IE 8]><meta http-equiv="refresh" content="0;url=\'+T.e(c,v,\'url\')+\'"><![endif]--> \'',1:'\' <noscript><meta http-equiv="refresh" content="0;url=\'+T.e(c,v,\'url\')+\'"></noscript> \'',2:'\'<meta charset="\'+T.e(c,v,\'charset\')+\'">\'',3:'\'<meta http-equiv="X-UA-Compatible" content="\'+T.e(c,v,\'X-UA-Compatible\')+\'" />\'',4:'\'<meta name="viewport" content="\'+T.e(c,v,\'viewport\')+\'" />\'',5:'\'<meta name="google" value="notranslate" />\'',6:'\'\'+T.e(c,v,\'name\')+\'="\'+T.e(c,v,\'value\')+\'"\'',7:'\' <meta \'+T.s(s,c,v,\'attributes\', s[6])+\'> \'',8:'\'?version=\'+T.e(c,v,\'.\')+\'\'',9:'\' <link type="text/css" href="\'+T.e(c,v,\'.\')+\'\'+T.s(s,c,v,\'version\', s[8])+\'" rel="stylesheet"> \'',10:'\'?version=\'+T.e(c,v,\'.\')+\'\'',11:'\' <script src="\'+T.e(c,v,\'.\')+\'\'+T.s(s,c,v,\'version\', s[10])+\'"></script> \''};module.exports=function(c){var c={c:c,p:0};return'<head><title>'+T.e(c,v,'title')+'</title> '+T.s(s,c,v,'backward-compatibility-redirect', s[0])+''+T.s(s,c,v,'noscript-redirect', s[1])+' '+T.s(s,c,v,'charset', s[2])+' '+T.s(s,c,v,'X-UA-Compatible', s[3])+' '+T.s(s,c,v,'viewport', s[4])+' '+T.s(s,c,v,'google-notranslate', s[5])+' <!-- Turn on IE cleartype --><meta http-equiv="cleartype" content="on"> '+T.s(s,c,v,'custom-meta', s[7])+''+T.s(s,c,v,'css-files', s[9])+''+T.s(s,c,v,'script-files', s[11])+'</head> '}
},{"icebrace-runtime":"icebrace-runtime"}],14:[function(require,module,exports){
"use strict";
var T=require("icebrace-runtime"),v,s={0:'\'\'+T.c(\'meta-head\', c.c)+\'\'',1:'\'.min\'',2:'\'?version=\'+T.e(c,v,\'.\')+\'\'',3:'\'.min\'',4:'\'?version=\'+T.e(c,v,\'.\')+\'\''};module.exports=function(c){var c={c:c,p:0};return'<!DOCTYPE html><html> '+T.s(s,c,v,'head', s[0])+' <body><div id="content"> '+T.c('basic-loader', c.c)+' </div><script src="framework'+T.s(s,c,v,'min', s[1])+'.js'+T.s(s,c,v,'fw_version', s[2])+'"></script><script src="bundle'+T.s(s,c,v,'min', s[3])+'.js'+T.s(s,c,v,'version', s[4])+'"></script></body></html> '}
},{"icebrace-runtime":"icebrace-runtime"}],15:[function(require,module,exports){
"use strict";
require('./middleware/middleware')(
	polyfills,
	require('./middleware/initEnvironment'),
	require('./middleware/loadConfig'),
	require('./middleware/i18n'),
	require('./middleware/setLogLevel'),
	setupApp,
	changeLanguage,
	startApp
);

var BaseModel, Conference;

/**
 * @param {Object} data 
 * @param {Function} next 
 * @returns {undefined}
 */
function polyfills(data, next) {
	require('classlist-polyfill');
	require('svg4everybody')();
	require('es6-object-assign/auto');
	window.Promise = window.Promise || require('promise-polyfill');
	SVGElement.prototype.contains = SVGElement.prototype.contains || HTMLDivElement.prototype.contains;

	Element.prototype.matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

	Element.prototype.closest = Element.prototype.closest || function (s) {
		var el = this;

		do {
			if (el.matches(s)) {
				return el;
			}
			el = el.parentElement || el.parentNode;
		} while (el !== null && el.nodeType === 1);
		return null;
	};

	Element.prototype.toggleAttribute = Element.prototype.toggleAttribute || function (name, force) {
		if (force !== void 0) {
			force = !!force;
		}
		if (this.hasAttribute(name)) {
			if (force) {
				return true;
			}
			this.removeAttribute(name);
			return false;
		}
		if (force === false) {
			return false;
		}
		this.setAttribute(name, '');
		return true;
	};

	next();
}

var openerMessageTimeout;

/**
 * 
 * @param {Object} data 
 * @param {Function} next 
 * @returns {undefined}
 */
function setupApp(data, next) {
	var meetingId = location.toString().split('/').pop() + '_' + location.hostname;
	BaseModel = require('BaseModel');


	require('./communication-xml.js');
	/**
	 * Call communication command on model
	 * @param {String} command
	 * @param {Object} args
	 * @param {Object} [callback]
	 * @returns {unresolved} response
	 */
	BaseModel.prototype.callCommunication = function (command, args, callback) {
		var context = this;
		if (callback) {
			return this.com[command].call(this, args, callback);
		}
		return new Promise(function (resolve, reject) {
			context.com[command].call(context, args, {
				success: resolve,
				error: reject
			});
		});
	};

	Conference = BaseModel.instance('Conference');
	Conference.setData('meetingId', meetingId)

	if (window.opener) {
		addEventListener('message', messageHandler.bind(null, next));
		openerMessageTimeout = setTimeout(function () {
			next();
		}, 500);
		return opener.postMessage({
			event: 'setup',
			cid: meetingId,
			type: 'conference'
		}, '*');
	}

	next();
}

function messageHandler(next, event) {
	if (event.data.cid === Conference.getData('meetingId') && event.data.event === 'setup') {
		clearTimeout(openerMessageTimeout);
		for (var i in event.data.data) {
			event.data.data[i] && Conference.setData(i, event.data.data[i]);
		}
		localStorage.setItem('language', event.data.data.language);
		next();
	}
}

/**
 * 
 * @param {Object} data 
 * @param {Function} next 
 * @returns {undefined}
 */
function changeLanguage(data, next) {
	var Language = BaseModel.static('Language');
	Language.changeLanguage(Language.getLanguageCode(), {
		success: next,
		error: next
	});
}

/**
 * 
 * @param {Object} data 
 * @param {Function} next 
 * @returns {undefined}
 */
function startApp() {
	var BaseController = require('BaseController');
	var isWebkit = 'WebkitAppearance' in document.documentElement.style;
	var application = BaseController.new('application-conference');

	document.title = __('title');

	if (!isWebkit) {
		renderApp.call(application);
	} else if (Conference.getData('session')) {
		Conference.authenticateWebclient(Conference.getData('session'), {
			success: function () {
				Conference.getSessionInfo({
					success: function (sessionInfo) {
						Conference.setData('username', sessionInfo.email);
						Conference.getJWT({
							success: application.initJitsi.bind(null, true),
							error: renderApp.bind(application)
						});
					},
					error: renderApp.bind(application)
				});
			},
			error: function() {
				if (Conference.getData('username')) {
					Conference.getJWT({
						success: application.initJitsi.bind(null, true),
						error: renderApp.bind(application)
					});
				} else {
					renderApp.call(application);
				}
			}
		});
	} else {
		renderApp.call(application);
	}
}

function renderApp() {
	this.execute().then(function (controller) {
		controller.render(document.getElementById('content'));
	});
}

},{"./communication-xml.js":16,"./middleware/i18n":30,"./middleware/initEnvironment":31,"./middleware/loadConfig":32,"./middleware/middleware":33,"./middleware/setLogLevel":34,"BaseController":"BaseController","BaseModel":"BaseModel","classlist-polyfill":64,"es6-object-assign/auto":65,"promise-polyfill":72,"svg4everybody":73}],16:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var Conference = BaseModel.static('Conference');
Conference.prototype.com= new (require('./communication/xml/Conference/ConferencePrototype.js'))();

},{"./communication/xml/Conference/ConferencePrototype.js":17,"BaseModel":"BaseModel"}],17:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var Callback = require('Callback');
var Request = require('request');
var OldCommunication = require('@icewarp/old-communication');

var icewarpapi;

/**
 * Communication for Conference model
 * @class ConferencePrototype
 */
function ConferencePrototype() {
	var config = BaseModel.instance('Config').getData('config');
	var apiPath = '//' + location.host + '/icewarpapi/';

	icewarpapi = new OldCommunication(OldCommunication.XHR, 'icewarpapi', {
		host: config && config.icewarpapi || apiPath,
		xmlns: 'admin:iq:rpc'
	});
}

ConferencePrototype.prototype.getJWT = function (callback) {
	var params = {
		meetingid: this.getData('meetingId'),
		username: this.getData('username')
	};
	var password = this.getData('password');
	if (password) {
		params.password = password;
	}
	var avatar = this.getData('avatar');
	if (avatar) {
		params.avatar = avatar;
	}

	send('getjitsijwt', params, {
		success: function (response) {
			var config = BaseModel.instance('Config').getData('config');
			var i;
			if (!response) {
				return Callback(Callback.ERROR, callback, 'wrong_password');
			}

			for (i in response || {}) {
				response[i] && this.setData(i, response[i]);
			}
			this.setData('server', config.jitsi_server || this.getData('server') || 'https://conference.icewarp.com');

			Callback(Callback.SUCCESS, callback);
		}.bind(this),
		error: callback.error,
		context: callback.context
	});
}

ConferencePrototype.prototype.authenticateWebclient = function (session_id, callback) {
	var params = {
		webclientsessionid: session_id
	};

	send('authenticatewebclient', params, {
		success: function (result, response) {
			icewarpapi.iq.addAttribute('sid', response._attributes.sid);
			Callback(Callback.SUCCESS, callback);
		},
		error: callback.error,
		context: callback.context
	});
}

ConferencePrototype.prototype.getSessionInfo = function (callback) {
	send('getsessioninfo', {}, callback)
}

ConferencePrototype.prototype.getMeetingInfo = function (args, callback) {
	send('GWGetMeetingInfo', {
		meetingid: this.getData('meetingId')
	}, {
		success: function (response) {
			var i;
			response = response || {};
			if (!response.organizer) {
				return Callback(Callback.ERROR, callback, {
					heading: __('error.wrong_meeting_id_heading'),
					code: 'wrong_meeting_id'
				});
			}
			for (i in response) {
				response[i] && this.setData(i, response[i]);
			}
			Callback(Callback.SUCCESS, callback);
		}.bind(this),
		error: callback && callback.error,
		context: callback && callback.context
	});
}

ConferencePrototype.prototype.getParticipants = function (callback) {
	var i, request, parsedData = [];
	var data = {
		token: this.getData('jwt'),
		room: this.getData('roomname')
	};

	for (i in data) {
		parsedData.push(encodeURIComponent(i) + '=' + encodeURIComponent(data[i]));
	}
	request = new Request({
		url: this.getData('server') + '/room?' + parsedData.join('&'),
		method: "GET"
	});

	request.on('load', function (event, xhr) {
		var participants = [];
		switch(xhr.status) {
			case 200:
				try {
					participants = JSON.parse(xhr.response);
				} catch (e) {}
			case 404: // room not found
				Callback(Callback.SUCCESS, callback, participants);
				break;
			default: // invalid token
				Callback(Callback.ERROR, callback, {
					code: xhr.status
				});
		}
	});

	request.on('error', function (error) {
		Callback(Callback.ERROR, callback, error);
	});

	request.send();
}

/**
 * Send request
 * @param {String} command 
 * @param {Object} params 
 * @param {Callback} callback 
 * @returns {undefined}
 */
function send(command, params, callback) {
	icewarpapi.send({
		commandname: command,
		commandparams: params
	}, callback)
}

module.exports = ConferencePrototype;

},{"@icewarp/old-communication":55,"BaseModel":"BaseModel","Callback":"Callback","request":"request"}],18:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var BaseController = require('BaseController');
var Animations = require('@icewarp/utils').animations;

var ApplicationConference = BaseController.create('ApplicationConference');
var Conference;

ApplicationConference.prototype.onCreate = function () {
	Conference = BaseModel.instance('Conference');
};

ApplicationConference.prototype.helper = function () {
	var isWebkit = 'WebkitAppearance' in document.documentElement.style;
	if (!isWebkit) {
		this.data.error = {
			code: 'browser_unsupported_helper',
			heading: __('error.browser_unsupported')
		}
	}

	if (this.data.error) {
		return {
			conference: BaseController.new('feature-conference~error', this.data.error)
		};
	}

	return Conference.getMeetingInfo().then(function () {
		return {
			conference: BaseController.new(
				(Conference.getData('passwordprotected') > 0 && !Conference.getData('password')) ?
				'feature-conference~locked' :
				'feature-conference~name'
			)
		};
	}.bind(this), function (error) {
		return {
			conference: BaseController.new('feature-conference~error', error)
		};
	});
};

ApplicationConference.prototype.initJitsi = function (skip_jwt) {
	var interval;

	var script = document.createElement('script');
	script.src = Conference.getData('server') + '/external_api.js';
	document.head.appendChild(script);

	interval = setInterval(function () {
		if (window.JitsiMeetExternalAPI) {
			clearInterval(interval);
			if (skip_jwt) {
				return renderJitsi();
			}
			Conference.getJWT({
				success: renderJitsi
			});
		}
	}, 50);
}

function renderJitsi() {
	var options = {
		jwt: Conference.getData('jwt'),
		roomName: Conference.getData('roomname'),
		parentNode: document.body,
		onload: function () {
			if (Conference.getData('subject')) {
				api.executeCommand('subject', Conference.getData('subject'));
				document.title += ' - ' + Conference.getData('subject');
			}

			setInterval(function () {
				localStorage.setItem('last_running_conference_timestamp', +new Date());
			}, 1000);

			postmessage({
				data: {
					jwt: Conference.getData('jwt'),
					roomname: Conference.getData('roomname'),
					server: Conference.getData('server')
				},
				event: 'load'
			});

			api.getIFrame().contentWindow.postMessage({
				data: {
					logo: location.origin + location.pathname.replace(/\d+$/, '') + '/download.php?class=jitsi_logo&fullpath=true&fallback=' + encodeURIComponent(Conference.getData('server')) + '/images/watermark.png',
					link: document.location.toString(),
					i18n: {
						button: __('conference.copy_link.button'),
						success: __('conference.copy_link.success')
					}
				},
				event: 'setup'
			}, '*');
		}
	};

	while (document.body.firstChild) {
		document.body.removeChild(document.body.lastChild);
	}

	var api = new JitsiMeetExternalAPI(Conference.getData('server').replace(/^https?:\/\//, ''), options);

	['participantRoleChanged', 'participantJoined', 'participantLeft', 'readyToClose'].forEach(function (event) {
		api.addEventListener(event, function (data) {
			postmessage({
				data: data,
				event: event
			});
		});
	});

	addEventListener('message', function (event) {
		if ((event.data.cid && event.data.cid !== Conference.getData('meetingId')) || !event.data.event) {
			return;
		}

		switch (event.data.event) {
			case 'load':
				postmessage({
					event: 'load',
					data: response
				});
				break;
			default:
				event.data.event && postmessage({
					mid: event.data.mid,
					data: api[event.data.event].apply(api, event.data.args || [])
				})
		}
	}, false);
};

function postmessage(data) {
	data = data || {};
	data.cid = Conference.getData('meetingId');
	data.type = 'conference';
	window.opener && opener.postMessage(data, '*');
}

module.exports = ApplicationConference;

},{"@icewarp/utils":62,"BaseController":"BaseController","BaseModel":"BaseModel"}],19:[function(require,module,exports){
"use strict";
var BaseController = require('BaseController');

var Base = BaseController.create('Base');

Base.prototype.addListeners = function() {
	var i;
	for (i in this.data) {
		!i.indexOf('handle') && this.data[i] && this.addDOMListener('', i.replace('handle', '').toLowerCase(), this.data[i]);
	}
};

module.exports = Base;

},{"BaseController":"BaseController"}],20:[function(require,module,exports){
"use strict";
var Base = require('./../../base');
var BasicInput = Base.create('BasicInput');

BasicInput.prototype.value = function(value) {
	if (value !== void 0) {
		return this.DOMElement.value = value;
	}
	return this.DOMElement.value.trim();
};

module.exports = BasicInput;

},{"./../../base":19}],21:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var BaseController = require('BaseController');
var ComponentAvatar = BaseController.create('ComponentAvatar');

ComponentAvatar.prototype.helper = function () {
	var initials;
	if (!this.data.image_path) {
		if (this.data.name) {
			initials = this.data.name.split(' ');
			initials = initials.splice(0, 1).concat([initials.pop()]).filter(Boolean).map(function (name) {
				return name.substr(0, 1);
			}).join('');
		} else {
			initials = this.data.email.substr(0, 1);
		}
	}
	return this.data.email ? {
		image: this.data.image_path,
		letter: initials,
		class_name: this.data.class_name,
		mod: this.data.mod
	} : {};
};

module.exports = ComponentAvatar;

},{"BaseController":"BaseController","BaseModel":"BaseModel"}],22:[function(require,module,exports){
"use strict";
var Base = require('../../base');
var ComponentButton = Base.create('ComponentButton');

module.exports = ComponentButton;

},{"../../base":19}],23:[function(require,module,exports){
"use strict";
var BaseController = require('BaseController');
var FeatureConference_Error = BaseController.create('FeatureConference_Error');

var ERROR_CODE = {
	403: 'invalid_token'
};

FeatureConference_Error.prototype.helper = function () {
	return {
		mod: 'generic',
		icon: BaseController.new('component-icon-document', {
			icon: BaseController.new('basic-icon', {
				set: 'emoji',
				type: 'conference'
			}),
			mod: 'wrong'
		}),
		message: BaseController.new('component-message-document', {
			type: 'generic',
			mod: 'coll',
			fileinfo: this.data.heading || __('error.heading'),
			docmsg: __('error.' + (ERROR_CODE[this.data.code] || this.data.code || 'unknown'))
		}),
		image: 'images/ups.svg'
	};
};

module.exports = FeatureConference_Error;

},{"BaseController":"BaseController"}],24:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var BaseController = require('BaseController');
var FeatureConference = require('./conference~name');
var FeatureConference_Locked = FeatureConference.create('FeatureConference_Locked');
var Animations = require('@icewarp/utils').animations;

FeatureConference_Locked.prototype.onCreate = function () {
	this.input = BaseController.new('basic-input', {
		placeholder: __('locked.password.placeholder'),
		type: 'password',
		handleKeyup: function (e) {
			var event;
			this.submitButton.DOMElement.toggleAttribute('disabled', !this.input.value().length);
			if (e.key === 'Enter') {
				event = document.createEvent('Event');
				event.initEvent('click', false, true);
				this.submitButton.DOMElement.dispatchEvent(event);
			}
		}.bind(this)
	});

	this.errorMessage = BaseController.new('basic-text', {
		text: __('locked.password.error'),
		icon: BaseController.new('basic-icon', {
			set: 'ui',
			type: 'error'
		})
	});

	this.password = BaseController.new('component-input', {
		mod: ['coll', 'collpass'],
		label: {
			text: __('locked.password.label')
		},
		element: this.input,
		desc: this.errorMessage
	});

	this.submitButton = BaseController.new('component-button', {
		text: __('conference.meet_now'),
		mod: ['coll-main', 'conference'],
		disabled: true,
		handleClick: function () {
			var Conference = BaseModel.instance('Conference');
			Conference.setData('password', this.input.value());
			Conference.getJWT({
				success: unlock,
				error: this.error,
				context: this
			});
		}.bind(this)
	});
};

FeatureConference_Locked.prototype.afterRender = function () {
	this.errorMessage.DOMElement.setAttribute('hidden', '');
	this.password.view_data.element.DOMElement.focus();
};

function unlock() {
	var Conference = BaseModel.instance('Conference');
	var parentNode = this.getParent('application-conference').DOMElement;
	if (Animations.browserEvent('animationend')) {
		this.addDOMListener(this.DOMElement, Animations.browserEvent('animationend'), function () {
			if (Conference.getData('session')) {
				return initJitsi();
			}
			this.remove();
			BaseController.new('feature-conference~name').execute().then(function (controller) {
				controller.DOMShadowElement.classList.add('enter');
				controller.render(parentNode, 'beforeend');
			}.bind(this));
		}.bind(this), {}, true);
		this.DOMElement.classList.add('leave');
	} else {
		if (Conference.getData('session')) {
			return initJitsi();
		}
		this.remove();
		BaseController.new('feature-conference~name').execute().then(function (controller) {
			controller.render(parentNode, 'beforeend');
		}.bind(this));
	}
};

FeatureConference_Locked.prototype.error = function () {
	this.password.DOMElement.classList.toggle('c-input--collpass-error', true);
	this.errorMessage.DOMElement.removeAttribute('hidden');
	this.password.view_data.element.DOMElement.focus();

	if (Animations.browserEvent('animationend')) {
		this.addDOMListener(this.DOMElement, Animations.browserEvent('animationend'), function () {
			this.DOMElement.classList.remove('error');
		}.bind(this), {}, true);
		this.DOMElement.classList.add('error');
	} else {
		this.DOMElement.classList.add('error');
		setTimeout(function () {
			this.DOMElement.classList.remove('error');
		}.bind(this), 500);
	}
};

FeatureConference_Locked.prototype.helper = function () {
	var Conference = BaseModel.instance('Conference');
	return {
		icon: BaseController.new('component-icon-document', {
			icon: BaseController.new('basic-icon', {
				set: 'emoji',
				type: 'conference'
			}),
			locked: BaseController.new('component-icon-document', {
				icon: BaseController.new('basic-icon', {
					set: 'ui',
					type: 'locked',
				}),
				mod: 'locked',
			})
		}),
		message: BaseController.new('component-message-document', {
			type: 'conference',
			mod: ['coll', 'blur'],
			fileinfo: __('locked.heading')
		}),
		activity: __('conference.organizer', {
			name: Conference.getData('organizer_name') || Conference.getData('organizer')
		}),
		avatar: BaseController.new('component-avatar', {
			email: Conference.getData('organizer'),
			name: Conference.getData('organizer_name')
		}),
		input: this.password,
		button: this.submitButton
	};
};

module.exports = FeatureConference_Locked;

},{"./conference~name":25,"@icewarp/utils":62,"BaseController":"BaseController","BaseModel":"BaseModel"}],25:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var BaseController = require('BaseController');
var IcewarpDate = require('@icewarp/date');
var Animations = require('@icewarp/utils').animations;

var FeatureConference_Name = BaseController.create('FeatureConference_Name_Name');

var Conference, valid_token = false;

FeatureConference_Name.prototype.onCreate = function () {
	Conference = BaseModel.instance('Conference');

	this.input = BaseController.new('basic-input', {
		value: Conference.getData('username'),
		placeholder: __('conference.name.placeholder'),
		handleKeyup: function (e) {
			if (e.key === 'Enter') {
				return handleSubmit.call(this)
			}
			enableSubmitButton.call(this);
		}.bind(this)
	});

	this.name = BaseController.new('component-input', {
		mod: 'coll',
		label: {
			text: __('conference.name.label')
		},
		element: this.input
	});

	this.submitButton = BaseController.new('component-button', {
		text: __('conference.meet_now'),
		mod: ['coll-main', 'conference'],
		disabled: true,
		handleClick: handleSubmit.bind(this)
	});
};

FeatureConference_Name.prototype.afterRender = function () {
	this.name.view_data.element.DOMElement.focus();
	Conference.getJWT({
		success: this.getPatricipants,
		context: this
	});

	if (Animations.browserEvent('animationend')) {
		this.addDOMListener(this.DOMElement, Animations.browserEvent('animationend'), function () {
			this.DOMElement.classList.remove('enter');
		}.bind(this), {}, true);
	} else {
		this.DOMElement.classList.remove('enter');
	}
};

function handleSubmit() {
	if (!this.input.value().length || !valid_token) {
		return;
	}
	Conference.setData('username', this.input.value());
	this.getParent('application-conference').initJitsi();
	this.remove();
}

function enableSubmitButton() {
	this.submitButton.DOMElement.toggleAttribute('disabled', !this.input.value().length || !valid_token);
}

FeatureConference_Name.prototype.getPatricipants = function () {
	Conference.getParticipants({
		success: function (participants) {
			valid_token = true;
			enableSubmitButton.call(this);
			var wrapper;
			if (!this.DOMElement) {
				return;
			}
			wrapper = this.DOMElement.querySelector('.c-feature-conference__activity');

			while (wrapper.firstChild) {
				wrapper.removeChild(wrapper.lastChild);
			}
			participants.forEach(function (participant) {
				BaseController.new('component-avatar', {
					email: participant.email,
					name: participant.display_name,
					image_path: participant.avatar
				}).execute().then(function (controller) {
					controller.render(wrapper, 'beforeend');
				});
			});
			setTimeout(this.getPatricipants.bind(this), 5000);
		},
		error: function (error) {
			if (!this.DOMElement) {
				return;
			}
			if (error) {
				return this.getParent('application-conference').rerender({
					error: error
				});
			}
			setTimeout(this.getPatricipants.bind(this), 1000);
		},
		context: this
	});
};

FeatureConference_Name.prototype.helper = function () {
	return {
		icon: BaseController.new('component-icon-document', {
			icon: BaseController.new('basic-icon', {
				set: 'emoji',
				type: 'conference'
			})
		}),
		message: BaseController.new('component-message-document', {
			type: 'conference',
			mod: ['coll', 'conference'],
			fileinfo: Conference.getData('subject') || __('locked.heading'),
			docmsg: +Conference.getData('startdate') ? timeHelper.call(this) : ''
		}),
		activity: ' ',
		input: this.name,
		button: this.submitButton
	};
};

function timeHelper() {
	var start = IcewarpDate.julian(+Conference.getData('startdate'), +Conference.getData('starttime'));
	var end = IcewarpDate.julian(+Conference.getData('enddate'), +Conference.getData('endtime'));
	var result;

	if (+Conference.getData('starttime') < 0) {
		if (+Conference.getData('startdate') < +Conference.getData('enddate') - 1) {
			return start.format('L') + ' - ' + end.format('L');
		}
		return CalendarFormatting.normalWithWeekDay(start);
	}
	result = CalendarFormatting.normalWithWeekDayAndTime(start);
	if (+Conference.getData('startdate') < +Conference.getData('enddate')) {
		result += ' - ' + CalendarFormatting.normalWithWeekDayAndTime(end);
	} else {
		result += ' - ' + end.format('LT');
	}
	return result;
};


var CalendarFormatting = {
	normal: function (date) {
		return date.calendar(null, {
			sameDay: '[' + __('date.today') + ']',
			nextDay: '[' + __('date.tomorrow') + ']',
			nextWeek: 'L',
			lastDay: '[' + __('date.yesterday') + ']',
			lastWeek: 'L',
			sameElse: 'L'
		});
	},
	normalWithTime: function (date) {
		return date.calendar(null, {
			sameDay: '[' + __('date.today') + '] LT',
			nextDay: '[' + __('date.tomorrow') + '] LT',
			nextWeek: 'L LT',
			lastDay: '[' + __('date.yesterday') + '] LT',
			lastWeek: 'L LT',
			sameElse: 'L LT'
		});
	},
	normalWithWeekDay: function (date) {
		var diff = Math.abs(date.diff(new Date(), 'days'));
		var withWeekDay = diff < 7 ? '[' + this.weekdayToString(date.day(), date < new Date()) + ']' : 'L';
		return this.normal(date, {
			sameElse: withWeekDay,
			lastWeek: withWeekDay,
			nextWeek: withWeekDay
		});
	},
	normalWithWeekDayAndTime: function (date) {
		var diff = Math.abs(date.diff(new Date(), 'days'));
		var withWeekDay = diff < 7 ? '[' + this.weekdayToString(date.day(), date < new Date()) + '] LT' : 'L LT';
		return this.normalWithTime(date, {
			sameElse: withWeekDay,
			lastWeek: withWeekDay,
			nextWeek: withWeekDay
		});
	},
	weekdayToString: function (week_day, in_the_past) {
		return 'sunday,monday,tuesday,wednesday,thursday,friday,saturday'.split(',').map(function (day) {
			return __('date.' + (in_the_past ? 'last_' : '') + day.toUpperCase());
		})[week_day];
	}
};

module.exports = FeatureConference_Name;

},{"@icewarp/date":43,"@icewarp/utils":62,"BaseController":"BaseController","BaseModel":"BaseModel"}],26:[function(require,module,exports){
"use strict";
module.exports={'base':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/base.js')},'application-conference':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/application/conference/conference.js')},'basic-input':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/basic/input/input.js')},'feature-conference~locked':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/feature/conference/conference~locked.js')},'feature-conference~error':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/feature/conference/conference~error.js')},'feature-conference~name':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/feature/conference/conference~name.js')},'component-avatar':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/component/avatar/avatar.js')},'component-button':function(){return require('C:/BuildAgent/work/da7c5b0a008b1020/merged/components/component/button/button.js')}};
},{"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/application/conference/conference.js":18,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/base.js":19,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/basic/input/input.js":20,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/component/avatar/avatar.js":21,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/component/button/button.js":22,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/feature/conference/conference~error.js":23,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/feature/conference/conference~locked.js":24,"C:/BuildAgent/work/da7c5b0a008b1020/merged/components/feature/conference/conference~name.js":25}],27:[function(require,module,exports){
module.exports={"title":"IceWarp Conference","conference":{"meet_now":"Meet now","name":{"label":"Your name","placeholder":"Enter your name here..."},"organizer":"**%{name}** is organizer of this conference","copy_link":{"button":"Copy link","success":"Link copied to clipboard"}},"date":{"sunday":"Sunday","monday":"Monday","tuesday":"Tuesday","wednesday":"Wednesday","thursday":"Thursday","friday":"Friday","saturday":"Saturday","last_sunday":"Last Sunday","last_monday":"Last Monday","last_tuesday":"Last Tuesday","last_wednesday":"Last Wednesday","last_thursday":"Last Thursday","last_friday":"Last Friday","last_saturday":"Last Saturday","today":"Today","yesterday":"Yesterday","tomorrow":"Tomorrow"},"error":{"invalid_token":"Wrong authorization token","heading":"Oops. Something went wrong.","wrong_meeting_id_heading":"Oops. The conference no longer exists.","wrong_meeting_id":"Please contact the organiser to get an updated link.","browser_unsupported":"It looks like you are using a browser we do not fully support.","browser_unsupported_helper":"We recommend using the latest version of Chrome or Chromium-based browser.","unknown":"We are working on getting this fixed as soon as we can."},"locked":{"heading":"Unknown room name","password":{"error":"Incorrect password. Please, try it again.","label":"Password","placeholder":"Enter password here..."}}}
},{}],28:[function(require,module,exports){
module.exports={"en":{"label":"English","direction":"ltr"}}
},{}],29:[function(require,module,exports){
"use strict";
/**
 * @see {@link https://stackoverflow.com/a/48275932}
 * @param {*} target 
 * @param {*} source 
 */
function mergeDeep(target, source) {
	var key;
	if (typeof target == "object" && typeof source == "object") {
		for (key in source) {
			if (source[key] === null && (target[key] === undefined || target[key] === null)) {
				target[key] = null;
			} else if (source[key] instanceof Array) {
				if (!target[key]) target[key] = [];
				//concatenate arrays
				target[key] = target[key].concat(source[key]);
			} else if (typeof source[key] == "object") {
				if (!target[key]) target[key] = {};
				mergeDeep(target[key], source[key]);
			} else {
				target[key] = source[key];
			}
		}
	}
	return target;
}

module.exports = mergeDeep;

},{}],30:[function(require,module,exports){
"use strict";
var I18n = require('@icewarp/i18n');
var config = require('C:\\BuildAgent\\work\\da7c5b0a008b1020\\src\\_config.json');

/**
 * Init translations
 * @param {Object} data
 * @param {*} next
 * @returns {undefined}
 */
function i18n(data, next) {
	config.i18n = config.i18n || {};

	I18n.init({
		url: config.i18n.url || 'locale/',
		expose: config.i18n.expose || '__',
		default_locale: config.i18n.default_locale || 'en',
		default_locale_dictionary: config.i18n.default_locale_dictionary || require('./../locale/en.json'),
		supported_languages: config.i18n.supported_languages || require('./../locale/languages.json'),
		external_url: config.i18n.external_url,
		version: config.i18n.version,
		project_name: config.project_name
	});
	next();
}

module.exports = i18n;

},{"./../locale/en.json":27,"./../locale/languages.json":28,"@icewarp/i18n":49,"C:\\BuildAgent\\work\\da7c5b0a008b1020\\src\\_config.json":75}],31:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var BaseController = require('BaseController');
var Template = require('icebrace-runtime');

/**
 * Environment initialization
 * set models, controllers, templates
 * 
 * @param {*} data
 * @param {function} next
 * @returns {undefined}
 * @ignore
 */
function initEnvironment(data, next) {
	BaseModel.setModels(require('./../models-list.js'));
	BaseController.setControllers(require('./../controllers-list.js'));
	Template.setTemplates(require('./../templates-list.js'));
	next();
}

module.exports = initEnvironment;

},{"./../controllers-list.js":26,"./../models-list.js":35,"./../templates-list.js":39,"BaseController":"BaseController","BaseModel":"BaseModel","icebrace-runtime":"icebrace-runtime"}],32:[function(require,module,exports){
"use strict";
var config = require('C:\\BuildAgent\\work\\da7c5b0a008b1020\\src\\_config.json');
var BaseModel = require('BaseModel');
var Request = require('request');
var mergeDeep = require('./helpers/merge-deep');

/**
 * @description Load config from URL, if provided
 * @param {string} url
 * @param {function} callback
 * @returns {undefined}
 */
function request(url, callback) {
	if (!url) {
		return callback();
	}
	new Request({
		url: url
	})
		.on('load', function(e, xhr) {
			try {
				mergeDeep(config, JSON.parse(xhr.response || xhr.responseText));
			} catch (e) {
				console.info('Error while loading config', url, 'fallback', config);
			}
			callback();
		})
		.on('error', function() {
			console.info('Error while loading config', url, 'fallback', config);
			callback();
		})
		.send();
}

/**
 * Load config from ./_config, extend it by ./external_config.json and config from config.remote_config_url
 *
 * @param {*} data
 * @param {function} next
 * @returns {undefined}
 * @ignore
 */
module.exports = function(data, next) {
	var external_config_url =
		config.external_config_url ||
		(location.origin || location.protocol + '//' + location.hostname) +
			(location.pathname + '/external_config.json').replace('//', '/');

	BaseModel.instance('Config').setData('config', config);
	request(external_config_url, function() {
		request(config.remote_config_url, next);
	});
};

},{"./helpers/merge-deep":29,"BaseModel":"BaseModel","C:\\BuildAgent\\work\\da7c5b0a008b1020\\src\\_config.json":75,"request":"request"}],33:[function(require,module,exports){
"use strict";
/**
 * @returns {undefined}
 */
function Middleware() {
	if (!arguments[0]) {
		throw new Error('No middlewares specified');
	}

	runMiddleware(void 0, [].slice.call(arguments));
}

/**
 * 
 * @param {*} data 
 * @param {middleware[]} middlewares 
 * @returns {undefined}
 */
function runMiddleware(data, middlewares) {
	if (!middlewares.length) {
		return;
	}
	middlewares.shift()(data, function(data) {
		runMiddleware(data, middlewares.slice(0));
	});
}

module.exports = Middleware;

},{}],34:[function(require,module,exports){
"use strict";
var logger = require('logger');
var config = require('C:\\BuildAgent\\work\\da7c5b0a008b1020\\src\\_config.json');

/**
 * Set logger log level
 * 
 * @param {*} data
 * @param {function} next
 * @returns {undefined}
 * @ignore
 */
function setLogLevel(data, next) {
	logger.setLevel((config.logger || {}).level || (logger.INFO | logger.WARN | logger.ERROR));
	next();
}
module.exports = setLogLevel;

},{"C:\\BuildAgent\\work\\da7c5b0a008b1020\\src\\_config.json":75,"logger":"logger"}],35:[function(require,module,exports){
"use strict";
module.exports={'Conference':function(){return require('./models/Conference.js')},'Config':function(){return require('./models/Config.js')},'Language':function(){return require('./models/Language.js')}};
},{"./models/Conference.js":36,"./models/Config.js":37,"./models/Language.js":38}],36:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var Conference = BaseModel.create('Conference');

Conference.singleton = true;

Conference.prototype.authenticateWebclient = function (args, callback) {
	return this.callCommunication('authenticateWebclient', args, callback);
};

Conference.prototype.getSessionInfo = function (callback) {
	return this.callCommunication('getSessionInfo', callback);
};

Conference.prototype.getMeetingInfo = function (callback) {
	return this.callCommunication('getMeetingInfo', callback);
};

Conference.prototype.getJWT = function (callback) {
	return this.callCommunication('getJWT', callback);
};

Conference.prototype.getParticipants = function (callback) {
	return this.callCommunication('getParticipants', callback);
};

module.exports = Conference;

},{"BaseModel":"BaseModel"}],37:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');

var Config = BaseModel.create('Config');

Config.singleton = true;

module.exports = Config;

},{"BaseModel":"BaseModel"}],38:[function(require,module,exports){
"use strict";
var BaseModel = require('BaseModel');
var i18n = require('@icewarp/i18n');
var Callback = require('Callback');
var LocalStorage = require('@icewarp/localstorage');
var Language = BaseModel.create('Language');

Language.singleton = true;

Language.changeLanguage = function (language, callback) {
	i18n.changeLanguage(language, changeLanguage.bind(null, callback), changeLanguage.bind(null, callback));
};

Language.getLanguageCode = function () {
	return LocalStorage.getItem('language') || getBrowserLanguageCode() || 'en';
};

/**
 * @returns {String}
 */
function getBrowserLanguageCode() {
	var index;
	var browser_languages = (navigator.languages || []).concat([navigator.language || navigator.userLanguage]);
	for (index in browser_languages) {
		return browser_languages[index].split('-')[0].toLowerCase();
	}
}

/**
 * 
 * @param {Object} callback
 * @param {Object} language 
 * @param {String} language.code
 * @param {Boolean} language.rtl
 * @returns {undefined}
 */
function changeLanguage(callback, language) {
	document.body.setAttribute('dir', language.rtl ? 'rtl' : 'ltr');
	Callback(Callback.SUCCESS, callback);
}

module.exports = Language;

},{"@icewarp/i18n":49,"@icewarp/localstorage":54,"BaseModel":"BaseModel","Callback":"Callback"}],39:[function(require,module,exports){
"use strict";
module.exports={'application-conference':function(){return require('./_compiled/application-conference.js')},'basic-icon':function(){return require('./_compiled/basic-icon.js')},'basic-input':function(){return require('./_compiled/basic-input.js')},'basic-label':function(){return require('./_compiled/basic-label.js')},'basic-loader':function(){return require('./_compiled/basic-loader.js')},'basic-text':function(){return require('./_compiled/basic-text.js')},'component-avatar':function(){return require('./_compiled/component-avatar.js')},'component-icon-document':function(){return require('./_compiled/component-icon-document.js')},'component-input':function(){return require('./_compiled/component-input.js')},'component-message-document':function(){return require('./_compiled/component-message-document.js')},'feature-conference':function(){return require('./_compiled/feature-conference.js')},'meta-head':function(){return require('./_compiled/meta-head.js')},'meta-index':function(){return require('./_compiled/meta-index.js')},'component-button':function(){return require('./_compiled/component-button.js')}};
},{"./_compiled/application-conference.js":1,"./_compiled/basic-icon.js":2,"./_compiled/basic-input.js":3,"./_compiled/basic-label.js":4,"./_compiled/basic-loader.js":5,"./_compiled/basic-text.js":6,"./_compiled/component-avatar.js":7,"./_compiled/component-button.js":8,"./_compiled/component-icon-document.js":9,"./_compiled/component-input.js":10,"./_compiled/component-message-document.js":11,"./_compiled/feature-conference.js":12,"./_compiled/meta-head.js":13,"./_compiled/meta-index.js":14}],40:[function(require,module,exports){
module.exports={
    "af": {
        "country": "Afghanistan",
        "language": "pa"
    },
    "al": {
        "country": "Albania",
        "language": "sq"
    },
    "dz": {
        "country": "Algeria",
        "language": "ar"
    },
    "ad": {
        "country": "Andorra",
        "language": "en"
    },
    "ao": {
        "country": "Angola",
        "language": "en"
    },
    "ag": {
        "country": "Antigua and Barbuda",
        "language": "en"
    },
    "ar": {
        "country": "Argentina",
        "language": "es"
    },
    "am": {
        "country": "Armenia",
        "language": "hy"
    },
    "au": {
        "country": "Australia",
        "language": "en"
    },
    "at": {
        "country": "Austria",
        "language": "de"
    },
    "az": {
        "country": "Azerbaijan",
        "language": "az"
    },
    "bs": {
        "country": "Bahamas",
        "language": "en"
    },
    "bh": {
        "country": "Bahrain",
        "language": "ar"
    },
    "bd": {
        "country": "Bangladesh",
        "language": "en"
    },
    "bb": {
        "country": "Barbados",
        "language": "en"
    },
    "by": {
        "country": "Belarus",
        "language": "be"
    },
    "be": {
        "country": "Belgium",
        "language": "wa"
    },
    "bz": {
        "country": "Belize",
        "language": "en"
    },
    "bj": {
        "country": "Benin",
        "language": "en"
    },
    "bt": {
        "country": "Bhutan",
        "language": "en"
    },
    "bo": {
        "country": "Bolivia",
        "language": "es"
    },
    "ba": {
        "country": "Bosnia and Herzegovina",
        "language": "bs"
    },
    "bw": {
        "country": "Botswana",
        "language": "en"
    },
    "br": {
        "country": "Brazil",
        "language": "pt"
    },
    "bn": {
        "country": "Brunei",
        "language": "ms"
    },
    "bg": {
        "country": "Bulgaria",
        "language": "bg"
    },
    "bf": {
        "country": "Burkina Faso",
        "language": "en"
    },
    "bi": {
        "country": "Burundi",
        "language": "en"
    },
    "kh": {
        "country": "Cambodia",
        "language": "en"
    },
    "cm": {
        "country": "Cameroon",
        "language": "en"
    },
    "ca": {
        "country": "Canada",
        "language": "fr"
    },
    "cv": {
        "country": "Cape Verde",
        "language": "en"
    },
    "cf": {
        "country": "Central African Republic",
        "language": "en"
    },
    "td": {
        "country": "Chad",
        "language": "en"
    },
    "cl": {
        "country": "Chile",
        "language": "es"
    },
    "cn": {
        "country": "China",
        "language": "zh"
    },
    "co": {
        "country": "Colombia",
        "language": "en"
    },
    "km": {
        "country": "Comoros",
        "language": "en"
    },
    "cd": {
        "country": "Congo, Democratic Republic of the",
        "language": "en"
    },
    "cg": {
        "country": "Congo, Republic of the",
        "language": "en"
    },
    "cr": {
        "country": "Costa Rica",
        "language": "es"
    },
    "ci": {
        "country": "Cote d'Ivoire",
        "language": "en"
    },
    "hr": {
        "country": "Croatia",
        "language": "hr"
    },
    "cu": {
        "country": "Cuba",
        "language": "en"
    },
    "cy": {
        "country": "Cyprus",
        "language": "el"
    },
    "cz": {
        "country": "Czech Republic",
        "language": "cs"
    },
    "dk": {
        "country": "Denmark",
        "language": "da"
    },
    "dj": {
        "country": "Djibouti",
        "language": "aa"
    },
    "dm": {
        "country": "Dominica",
        "language": "en"
    },
    "do": {
        "country": "Dominican Republic",
        "language": "es"
    },
    "ec": {
        "country": "Ecuador",
        "language": "es"
    },
    "eg": {
        "country": "Egypt",
        "language": "ar"
    },
    "sv": {
        "country": "El Salvador",
        "language": "es"
    },
    "gq": {
        "country": "Equatorial Guinea",
        "language": "en"
    },
    "er": {
        "country": "Eritrea",
        "language": "en"
    },
    "ee": {
        "country": "Estonia",
        "language": "et"
    },
    "et": {
        "country": "Ethiopia",
        "language": "en"
    },
    "fm": {
        "country": "Federated States of Micronesia",
        "language": "en"
    },
    "fj": {
        "country": "Fiji",
        "language": "en"
    },
    "fi": {
        "country": "Finland",
        "language": "sv"
    },
    "fr": {
        "country": "France",
        "language": "fr"
    },
    "ga": {
        "country": "Gabon",
        "language": "en"
    },
    "gm": {
        "country": "Gambia",
        "language": "en"
    },
    "ge": {
        "country": "Georgia",
        "language": "ab"
    },
    "de": {
        "country": "Germany",
        "language": "de"
    },
    "gh": {
        "country": "Ghana",
        "language": "en"
    },
    "gr": {
        "country": "Greece",
        "language": "el"
    },
    "gd": {
        "country": "Grenada",
        "language": "en"
    },
    "gt": {
        "country": "Guatemala",
        "language": "es"
    },
    "gn": {
        "country": "Guinea",
        "language": "en"
    },
    "gw": {
        "country": "Guinea-Bissau",
        "language": "en"
    },
    "gy": {
        "country": "Guyana",
        "language": "en"
    },
    "ht": {
        "country": "Haiti",
        "language": "en"
    },
    "hn": {
        "country": "Honduras",
        "language": "es"
    },
    "hu": {
        "country": "Hungary",
        "language": "hu"
    },
    "is": {
        "country": "Iceland",
        "language": "is"
    },
    "in": {
        "country": "India",
        "language": "te"
    },
    "id": {
        "country": "Indonesia",
        "language": "id"
    },
    "ir": {
        "country": "Iran",
        "language": "fa"
    },
    "iq": {
        "country": "Iraq",
        "language": "ar"
    },
    "ie": {
        "country": "Ireland",
        "language": "ga"
    },
    "il": {
        "country": "Israel",
        "language": "he"
    },
    "it": {
        "country": "Italy",
        "language": "it"
    },
    "hm": {
        "country": "Jamaica",
        "language": "en"
    },
    "jp": {
        "country": "Japan",
        "language": "ja"
    },
    "jo": {
        "country": "Jordan",
        "language": "ar"
    },
    "kz": {
        "country": "Kazakhstan",
        "language": "kk"
    },
    "ke": {
        "country": "Kenya",
        "language": "sw"
    },
    "ki": {
        "country": "Kiribati",
        "language": "en"
    },
    "kp": {
        "country": "Korea, North",
        "language": "en"
    },
    "kr": {
        "country": "Korea, South",
        "language": "ko"
    },
    "kw": {
        "country": "Kuwait",
        "language": "ar"
    },
    "kg": {
        "country": "Kyrgyz Republic",
        "language": "ky"
    },
    "la": {
        "country": "Laos",
        "language": "en"
    },
    "lv": {
        "country": "Latvia",
        "language": "lv"
    },
    "lb": {
        "country": "Lebanon",
        "language": "ar"
    },
    "ls": {
        "country": "Lesotho",
        "language": "en"
    },
    "lr": {
        "country": "Liberia",
        "language": "en"
    },
    "ly": {
        "country": "Libya",
        "language": "ar"
    },
    "li": {
        "country": "Liechtenstein",
        "language": "de"
    },
    "lt": {
        "country": "Lithuania",
        "language": "lt"
    },
    "lu": {
        "country": "Luxembourg",
        "language": "de"
    },
    "mk": {
        "country": "Macedonia",
        "language": "mk"
    },
    "mg": {
        "country": "Madagascar",
        "language": "en"
    },
    "mw": {
        "country": "Malawi",
        "language": "en"
    },
    "my": {
        "country": "Malaysia",
        "language": "ms"
    },
    "mv": {
        "country": "Maldives",
        "language": "dv"
    },
    "ml": {
        "country": "Mali",
        "language": "en"
    },
    "mt": {
        "country": "Malta",
        "language": "mt"
    },
    "mh": {
        "country": "Marshall Islands",
        "language": "en"
    },
    "mr": {
        "country": "Mauritania",
        "language": "en"
    },
    "mu": {
        "country": "Mauritius",
        "language": "en"
    },
    "mx": {
        "country": "Mexico",
        "language": "es"
    },
    "md": {
        "country": "Moldova",
        "language": "en"
    },
    "mc": {
        "country": "Monaco",
        "language": "fr"
    },
    "mn": {
        "country": "Mongolia",
        "language": "mn"
    },
    "ma": {
        "country": "Morocco",
        "language": "ar"
    },
    "mz": {
        "country": "Mozambique",
        "language": "en"
    },
    "mm": {
        "country": "Myanmar (Burma)",
        "language": "en"
    },
    "na": {
        "country": "Namibia",
        "language": "en"
    },
    "nr": {
        "country": "Nauru",
        "language": "en"
    },
    "np": {
        "country": "Nepal",
        "language": "en"
    },
    "nl": {
        "country": "Netherlands",
        "language": "nl"
    },
    "nz": {
        "country": "New Zealand",
        "language": "mi"
    },
    "ni": {
        "country": "Nicaragua",
        "language": "es"
    },
    "ne": {
        "country": "Niger",
        "language": "en"
    },
    "ng": {
        "country": "Nigeria",
        "language": "en"
    },
    "no": {
        "country": "Norway",
        "language": "nb"
    },
    "om": {
        "country": "Oman",
        "language": "ar"
    },
    "pk": {
        "country": "Pakistan",
        "language": "ur"
    },
    "pw": {
        "country": "Palau",
        "language": "en"
    },
    "pa": {
        "country": "Panama",
        "language": "es"
    },
    "pg": {
        "country": "Papua New Guinea",
        "language": "en"
    },
    "py": {
        "country": "Paraguay",
        "language": "es"
    },
    "pe": {
        "country": "Peru",
        "language": "es"
    },
    "ph": {
        "country": "Philippines",
        "language": "en"
    },
    "pl": {
        "country": "Poland",
        "language": "pl"
    },
    "pt": {
        "country": "Portugal",
        "language": "pt"
    },
    "qa": {
        "country": "Qatar",
        "language": "ar"
    },
    "ro": {
        "country": "Romania",
        "language": "ro"
    },
    "ru": {
        "country": "Russia",
        "language": "tt"
    },
    "rw": {
        "country": "Rwanda",
        "language": "en"
    },
    "kn": {
        "country": "Saint Kitts and Nevis",
        "language": "en"
    },
    "lc": {
        "country": "Saint Lucia",
        "language": "en"
    },
    "ws": {
        "country": "Samoa",
        "language": "en"
    },
    "sm": {
        "country": "San Marino",
        "language": "en"
    },
    "st": {
        "country": "Sao Tome and Principe",
        "language": "en"
    },
    "sa": {
        "country": "Saudi Arabia",
        "language": "ar"
    },
    "sn": {
        "country": "Senegal",
        "language": "en"
    },
    "sj": {
        "country": "Serbia",
        "language": "en"
    },
    "sc": {
        "country": "Seychelles",
        "language": "en"
    },
    "sl": {
        "country": "Sierra Leone",
        "language": "en"
    },
    "sg": {
        "country": "Singapore",
        "language": "zh"
    },
    "sk": {
        "country": "Slovakia",
        "language": "sk"
    },
    "si": {
        "country": "Slovenia",
        "language": "sl"
    },
    "sb": {
        "country": "Solomon Islands",
        "language": "en"
    },
    "so": {
        "country": "Somalia",
        "language": "en"
    },
    "za": {
        "country": "South Africa",
        "language": "zu"
    },
    "es": {
        "country": "Spain",
        "language": "es"
    },
    "lk": {
        "country": "Sri Lanka",
        "language": "en"
    },
    "sd": {
        "country": "Sudan",
        "language": "en"
    },
    "sr": {
        "country": "Suriname",
        "language": "en"
    },
    "sz": {
        "country": "Swaziland",
        "language": "en"
    },
    "se": {
        "country": "Sweden",
        "language": "sv"
    },
    "ch": {
        "country": "Switzerland",
        "language": "it"
    },
    "sy": {
        "country": "Syria",
        "language": "sy"
    },
    "tw": {
        "country": "Taiwan",
        "language": "zh"
    },
    "tj": {
        "country": "Tajikistan",
        "language": "en"
    },
    "tz": {
        "country": "Tanzania",
        "language": "en"
    },
    "th": {
        "country": "Thailand",
        "language": "en"
    },
    "tg": {
        "country": "Togo",
        "language": "en"
    },
    "to": {
        "country": "Tonga",
        "language": "en"
    },
    "tt": {
        "country": "Trinidad and Tobago",
        "language": "en"
    },
    "tn": {
        "country": "Tunisia",
        "language": "ar"
    },
    "tr": {
        "country": "Turkey",
        "language": "tr"
    },
    "tm": {
        "country": "Turkmenistan",
        "language": "en"
    },
    "tv": {
        "country": "Tuvalu",
        "language": "en"
    },
    "ug": {
        "country": "Uganda",
        "language": "en"
    },
    "ua": {
        "country": "Ukraine",
        "language": "uk"
    },
    "ae": {
        "country": "United Arab Emirates",
        "language": "ar"
    },
    "gb": {
        "country": "United Kingdom",
        "language": "en"
    },
    "us": {
        "country": "United States",
        "language": "en"
    },
    "uy": {
        "country": "Uruguay",
        "language": "es"
    },
    "uz": {
        "country": "Uzbekistan",
        "language": "uz"
    },
    "vu": {
        "country": "Vanuatu",
        "language": "en"
    },
    "va": {
        "country": "Vatican City (Holy See)",
        "language": "en"
    },
    "ve": {
        "country": "Venezuela",
        "language": "es"
    },
    "vn": {
        "country": "Vietnam",
        "language": "vi"
    },
    "ye": {
        "country": "Yemen",
        "language": "ar"
    },
    "zm": {
        "country": "Zambia",
        "language": "en"
    },
    "zw": {
        "country": "Zimbabwe",
        "language": "en"
    },
    "": {
        "country": "Other",
        "language": "en"
    }
}
},{}],41:[function(require,module,exports){
/** @module Calendars */


/**
 * Static class for handling calendars
 * @class Calendars
 */
var Calendars = {};
Calendars.GREGORIAN = 1;
Calendars.JALAALI = 2;
Calendars.HIJRI = 3;
Calendars.BUDDHA = 4;

Calendars.prefixes = {};
Calendars.prefixes[Calendars.GREGORIAN] = '';
Calendars.prefixes[Calendars.BUDDHA] = '';
Calendars.prefixes[Calendars.JALAALI] = 'j';
Calendars.prefixes[Calendars.HIJRI] = 'i';

Calendars.mods = {};
Calendars.mods[Calendars.JALAALI] = {
	years: 'jYear',
	year: 'jYear',
	months: 'jMonth',
	month: 'jMonth',
	days: 'jDay'
};
Calendars.mods[Calendars.HIJRI] = {
	years: 'iYear',
	year: 'iYear',
	months: 'iMonth',
	month: 'iMonth',
	days: 'iDay'
};
/**
 * Format prefix map
 */
Calendars.format = {};
Calendars.format[Calendars.JALAALI] = ['D+', 'Y+', 'M+', 'g+', 'w'];
Calendars.format[Calendars.HIJRI] = ['D+', 'Y+', 'M+', 'g+', 'w'];
/**
 * get regexp for matching prefixable formats
 * @param {number} [type]
 * @returns {Boolean|RegExp}
 */
Calendars.formatRegex = function (type) {
	type = type || this.type;
	return (this.format[type] && this.format[type].length) ? new RegExp('(' + this.format[type].join('|') + ')', 'g') : false;
};
/**
 * Prefix prefixable formats
 * @param {string} format
 * @param {number} [type]
 * @returns {string}
 */
Calendars.prefixFormat = function (format, type) {
	var regexp = this.formatRegex(type);
	return regexp ? format.replace(regexp, this.currentPrefix(type) + '$1') : format;
};
/**
 * Global type of calendar
 */
Calendars.type = 0;

/**
 * get current prefix by calendar type
 * @param {number} [type] if type is not provided, global type is used
 * @returns {String}
 */
Calendars.currentPrefix = function (type) {
	return this.prefixes[type || this.type] || '';
};
/**
 * Get modificated keyword for current calendar plugin
 * @param {string} keyword
 * @param {number} type
 * @returns {nm$_Calendars.Calendars.mods}
 */
Calendars.getMod = function (keyword, type) {
	return (this.mods[type || this.type] || {})[keyword] || keyword;
};
/**
 * Changing locale for alternative calendars
 * @param {string} locale
 * @returns {String}
 */
Calendars.alterLocale = function (locale) {
	if (locale !== 'ar') {
		return locale;
	}
	if (this.type === Calendars.JALAALI) {
		return 'fa';
	}
	if (this.type === Calendars.HIJRI) {
		return 'ar-sa';
	}
	return locale;
};

module.exports = Calendars;
},{}],42:[function(require,module,exports){
/** @module Formats */
var masks = {
	"default":"ddd MMM D YYYY HH:mm:ss",
	shortDate:"MM/D/YY",
	longDate:"MMMM D, YYYY",
	fullDate:"dddd, MMMM D, YYYY",
	shortTime:"hh:mm A",
	mediumTime:"h:mm:ss A",
	longTime:"h:mm:ss A zZZ",
	imDateTime:"YYYY-MM-DD[T]HH:mm:sszZZ",
	searchDate:"YYYY/MM/DD",
	isoDate:"YYYY-MM-DD",
	isoTime:"HH:mm:ss",
	isoDateTime:"YYYY-MM-DD[T]HH:mm:ss",
	isoFullDateTime:"YYYY-MM-DD[T]HH:mm:ss.SSSZZ",
	rfc2822:"ddd, DD MMM YYYY HH:mm:ss ZZ",
	mediumDate:"MM/D/YY HH:mm"
};

module.exports = masks;

},{}],43:[function(require,module,exports){
/**
 * @external PluginLoader
 */
/**
 * @external Calendars
 */
/**
 * @external Locale
 */
/**
 * @external Formats
 */
/**
 * @external moment
 * @see http://momentjs.com/docs/
 */
/**
 * @external moment-jalaali
 * @see https://github.com/jalaali/moment-jalaali
 */
/**
 * @external moment-hijri
 * @see https://github.com/xsoh/moment-hijri
 */
var PluginLoader = require('./PluginLoader');
var Moment = require('moment');
var jMoment = require('moment-jalaali');
var iMoment = require('moment-hijri');

jMoment.loadPersian();

PluginLoader();

var Calendars = require('./Calendars');

function selectCalendar(type) {
	switch (type) {
		case Calendars.GREGORIAN:
			return Moment;
		case Calendars.JALAALI:
			return jMoment;
		case Calendars.HIJRI:
			return iMoment;
		case Calendars.BUDDHA:
		default:
			return Moment;
	}
}

IcewarpDate.Calendars = Calendars;
IcewarpDate.Locale = require('./Locale');
var formats = require('./Formats');

/**
 * Access moment locale data
 */
Object.defineProperty(IcewarpDate, "locale_data", {
	get: function () {
		return Moment.localeData();
	}
});
IcewarpDate.firstDayOfWeek = function () {
	return Moment.localeData().firstDayOfWeek();
};

IcewarpDate.UNIX = 'X';
IcewarpDate.UNIX_MS = 'x';
IcewarpDate.JULIAN = 'julian';
IcewarpDate.JULIAN_TIME = 'julian_time';
/**
 * only time if it's same day, L otherwise
 */
IcewarpDate.SHORT_L = 'sL';
IcewarpDate.LOCAL_DATE = 'L';
IcewarpDate.LOCAL_TIME = 'LT';
IcewarpDate.LOCAL_TIME_SECONDS = 'LTS';

/**
 *
 * @param {array} weekdays
 * @returns {array}
 */
function reorderWeekdays(weekdays) {
	return weekdays.concat(weekdays.splice(0, Moment.localeData().firstDayOfWeek()));
}

/**
 * Convert julian day to unix timestamp in ms
 * @param {number} julian
 * @returns {Number}
 */
function julianDayToUnixMs(julian) {
	var calc1, calc2, year, month, day;
	julian = Math.floor(julian);
	calc1 = Math.floor(julian + 68569);
	calc2 = Math.floor(4 * calc1 / 146097);
	calc1 = calc1 - Math.floor((146097 * calc2 + 3) / 4);
	year = Math.floor(4000 * (calc1 + 1) / 1461001);
	calc1 = calc1 - Math.floor(1461 * year / 4) + 31;
	month = Math.floor(80 * calc1 / 2447);
	day = calc1 - Math.floor(2447 * month / 80);
	calc1 = Math.floor(month / 11);
	month = month + 2 - 12 * calc1;
	year = 100 * (calc2 - 49) + year + calc1;
	return (new IcewarpDate(new Date(), {calendar: Calendars.GREGORIAN})).year(year).month(month - 1).date(day).hour(0).minute(0).second(0).format('x');
}
/**
 * Convert IcewarpDate to julian day
 * @param {IcewarpDate} date
 * @returns {Number}
 */
function DateToJulianDay(date) {
	var a, y, m, jd, year = date.year(), month = date.month() + 1, day = date.date();
	a = Math.floor((14 - month) / 12);
	y = year + 4800 - a;
	m = month + 12 * a - 3;
	jd = day + (Math.floor((153 * m + 2) / 5)) + y * 365;
	return  jd + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
}

/**
 * Get access to Moment class
 * @returns {Moment}
 */
IcewarpDate.getMoment = function () {
	return Moment;
};

IcewarpDate.duration = Moment.duration;

/**
 *
 * @returns {unresolved}
 */
IcewarpDate.weekdaysShort = function () {
	return reorderWeekdays(Moment.localeData().weekdaysShort().slice(0));
};
/**
 *
 * @returns {unresolved}
 */
IcewarpDate.weekdays = function () {
	var weekdays = Moment.localeData().weekdays();
	return reorderWeekdays((weekdays.standalone || weekdays).slice(0));
};
/**
 *
 * @returns {unresolved}
 */
IcewarpDate.weekdaysMin = function () {
	return reorderWeekdays(Moment.localeData().weekdaysMin().slice(0));
};
/**
 * Get localizet list of month names
 * @returns {array}
 */
IcewarpDate.months = function () {
	var months = [];
	for (var i = 0; i < 12; i++) {
		months.push(new IcewarpDate().month(i).format('MMMM'));
	}
	return months;
};
/**
 *  Get localizet list of short month names
 * @returns {array}
 */
IcewarpDate.monthsShort = function () {
	var months = [];
	for (var i = 0; i < 12; i++) {
		months.push(new IcewarpDate().month(i).format('MMM'));
	}
	return months;
};

/**
 * Set global calendar.
 * All instances created without calendar property in options will be created by global caledar setting.
 * @param {number} calendar calendar type
 * @param {boolean} [skip_choose] skip choose of locale
 * @returns {IcewarpDate}
 */
IcewarpDate.setCalendar = function (calendar, skip_choose) {
	Calendars.type = calendar || 0;//todo
	!skip_choose && this.Locale.chooseLocale(Moment.locale());
	return this;
};
/**
 * Generate date from some weird cert date format
 * @param {string} date
 * @param {IcewarpDate~options} [options]
 * @returns {IcewarpDate}
 */
IcewarpDate.utct = function (date, options) {
	var default_options = {
		utc: !!~date.indexOf('Z'),
		format: "YYMMDDhhmmss"
	};
	for (var prop in options) {
		default_options[prop] = options[prop];
	}
	return new IcewarpDate(date, default_options);
};
/**
 * create date from julianday
 * @param {number} julianday
 * @param {number} [time_in_mins]
 * @param {IcewarpDate~options} [options]
 * @returns {IcewarpDate}
 */
IcewarpDate.julian = function (julianday, time_in_mins, options) {
	var default_options = {format: this.JULIAN};
	for (var prop in options) {
		default_options[prop] = options[prop];
	}
	var date = new IcewarpDate(julianday, default_options);
	date.hour(0);
	if (time_in_mins) {
		date.setTime(time_in_mins, true);
	}
	return date;
};
/**
 * Create date from unix
 * @param {number} unix
 * @param {IcewarpDate~options} [options]
 * @returns {IcewarpDate}
 */
IcewarpDate.unix = function (unix, options) {
	return new IcewarpDate(unix * 1000, options || {});
};

/**
 * Options object fro IcewarpDate constructor
 * @typedef {Object} IcewarpDate~options
 * @property {string} timezone - Timezone ID
 * @property {string} [format] format for date parser
 * @property {number} [calendar] number of alternative calendar
 * @property {boolean} [utc] date is in utc
 * @property {string} [locale] locale
 * @property {boolean} [clone] flag if we are cloning existing instance
 */

/**
 * @class IcewarpDate
 * @param {string|number} date
 * @param {IcewarpDate~options} [options]
 * @returns {IcewarpDate}
 */
function IcewarpDate(date, options) {
	options = options || {};
	this.calendar_type = options.calendar === void 0 ? Calendars.type : options.calendar;
	this.timezone = options.timezone || false;
	this.utc = options.utc || false;
	this.is_cloned = options.clone || false;
	var moment = selectCalendar(this.calendar_type);
	if (this.utc) {
		moment = moment.utc;
	}
	var format = options.format ? (formats[options.format] || options.format) : false;
	switch (format) {
		case false:
			if (date instanceof IcewarpDate) {
				this.moment = moment(date.getMoment());
			} else {
				this.moment = moment(date);
			}
			break;
		case IcewarpDate.JULIAN:
			this.moment = moment(Moment(julianDayToUnixMs(date), IcewarpDate.UNIX_MS)).hour(0).minute(0).second(0);
			break;
		default:
			this.moment = moment(Moment(date, format));
	}
	if ((this.calendar_type !== Calendars.type) || options.locale) {
		IcewarpDate.Locale.chooseLocale(options.locale || IcewarpDate.Locale.lang, this);
	}
	this.timezone && this.setTimezone(this.timezone);
	return this;
}

IcewarpDate.prototype.chooseLocale = function (locale) {
	IcewarpDate.Locale.chooseLocale(locale || IcewarpDate.Locale.lang, this);
	return this;
};
IcewarpDate.prototype.toString = function () {
	return this.moment.toString();
};
IcewarpDate.prototype.valueOf = function () {
	return this.moment.valueOf();
};

/**
 * Set Timezone for instance
 * @param {string} timezone Timezone ID
 * @returns {IcewarpDate}
 */
IcewarpDate.prototype.setTimezone = function (timezone) {
	if (typeof this.moment.tz === 'function') {
		this.moment.tz(timezone);
		return this;
	}
	console.warn("This build of IcewarpDate is not supporting Timezone manipulation");
};

/**
 * Set time by number of seconds
 * @param {number} time number of seconds since last midnight
 * @param {boolean} [minutes] time is in minutes
 * @returns {IcewarpDate}
 */
IcewarpDate.prototype.setTime = function (time, minutes) {
	if (minutes) {
		time *= 60;
	}
	var hours = Math.floor(time / 3600);
	minutes = Math.floor((time % 3600) / 60);
	var seconds = (time % 3600) % 60;
	this.moment.hours(hours).minutes(minutes).seconds(seconds);
	return this;
};

/**
 * Return formated datetime
 * @param {string} [format]
 * @param {boolean} [utc] convert to UTC
 * @returns {string|number}
 */
IcewarpDate.prototype.format = function (format, utc) {
	if (format === IcewarpDate.JULIAN) {
		return DateToJulianDay(this.moment.clone().hour(0).minute(0).second(0));
	}
	if (format === IcewarpDate.JULIAN_TIME) {
		return this.hour() * 60 + this.minute();
	}
	if (format === IcewarpDate.SHORT_L) {
		return this.format((!this.isSame(new IcewarpDate(), 'day') ? 'L' : '') + ' LT');
	}
	format = !format ? format : Calendars.prefixFormat(format, this.calendar_type);
	if (this.calendar_type === Calendars.BUDDHA) {
		return this.moment.clone().add(543, 'years').format(formats[format] || format);
	}
	return utc ? this.moment.utc().format(formats[format] || format) : this.moment.format(formats[format] || format);
};
/**
 * Calendar pring of date instance
 * @returns {string|number}
 */
IcewarpDate.prototype.calendar = function () {
	var moment = this.moment;
	if (this.calendar_type === Calendars.BUDDHA) {
		moment = this.moment.clone().add(543, 'years');
	}
	return moment.calendar.apply(moment, arguments);
};

/**
 * convert to gregorian calendar and get format
 * @param {string} format
 * @param {boolean} utc convert to UTC
 * @returns {undefined}
 */
IcewarpDate.prototype.gregorianFormat = function (format, utc) { //todo
	return this.format(formats[format] || format, utc);
};
/**
 * Get moment instance
 * @returns {moment}
 */
IcewarpDate.prototype.getMoment = function () {
	return this.moment;
};

/**
 *
 * @param {number} amount
 * @param {string} type
 * @returns {IcewarpDate}
 */
IcewarpDate.prototype.add = function (amount, type) {
	this.moment.add(amount, Calendars.getMod(type, this.calendar_type));
	return this;
};

IcewarpDate.prototype.startOf = function (type) {
	this.moment.startOf(Calendars.getMod(type, this.calendar_type));
	return this;
};
IcewarpDate.prototype.endOf = function (type) {
	this.moment.endOf(Calendars.getMod(type, this.calendar_type));
	return this;
};
/**
 *
 * @param {number} amount
 * @param {string} type
 * @returns {IcewarpDate}
 */
IcewarpDate.prototype.subtract = function (amount, type) {
	this.moment.subtract(amount, Calendars.getMod(type, this.calendar_type));
	return this;
};

function resultHandler(result) {
	if (result instanceof Moment || result instanceof jMoment || result instanceof iMoment) {
		return this;
	}
	return result;
}

/**
 * Dynamic caller for prefixed moment function
 * @param {string} fn_name
 * @returns {unresolved|IcewarpDate}
 */
IcewarpDate.prototype.prefixedCaller = function (fn_name) {
	var args = [].slice.call(arguments, 1).map(function (arg) {
		return (arg instanceof IcewarpDate) ? arg.getMoment() : arg;
	});
	if (this['_' + fn_name]) {
		return resultHandler.call(this, this.moment[this['_' + fn_name]].apply(this.moment, args));
	}
	var prefixed = Calendars.currentPrefix(this.calendar_type) + fn_name[0].toUpperCase() + fn_name.substr(1);
	this['_' + fn_name] = (Calendars.currentPrefix(this.calendar_type) && this.moment[prefixed]) ? prefixed : fn_name;
	return resultHandler.call(this, this.moment[this['_' + fn_name]].apply(this.moment, args));
};

/**
 * Overwritten moment year function
 * @param {number} year
 * @returns {number|IcewarpDate}
 */
IcewarpDate.prototype.year = function (year) {
	if (this.calendar_type === Calendars.BUDDHA) {
		if (!year) {
			return this.moment.clone().add(543, 'years').year();
		}
		arguments[0] -= 543;
	}
	var args = [].slice.call(arguments);
	args.unshift('year');
	return this.prefixedCaller.apply(this, args);
};
/**
 * Clone IcewarpDate instance
 * @param {IcewarpDate~options} [options]
 * @returns {IcewarpDate}
 */
IcewarpDate.prototype.clone = function (options) {
	var default_options = {
		timezone: this.timezone,
		calendar: this.calendar_type,
		clone: true
	};
	for (var prop in options) {
		default_options[prop] = options[prop];
	}
	return new IcewarpDate(this.moment.clone(), default_options);
};
/**
 *
 * @param {IcewarpDate} icewarp_date
 * @param {string} type
 * @returns {boolean}
 */
IcewarpDate.prototype.isSame = function (icewarp_date, type) {
	return this.moment.isSame(icewarp_date.getMoment(), type);
};

/**
 * Same day shortcut
 * @returns {Boolean}
 */
IcewarpDate.prototype.isToday = function () {
	return this.isSame(new IcewarpDate(), 'day');
};
/**
 * tommorow shortcut
 * @returns {Boolean}
 */
IcewarpDate.prototype.isTomorrow = function () {
	return this.isSame(new IcewarpDate().add(1, 'day'), 'day');
};
/**
 * Yesterday shortcut
 * @returns {Boolean}
 */
IcewarpDate.prototype.isYesterday = function () {
	return this.isSame(new IcewarpDate().subtract(1, 'day'), 'day');
};
/**
 * this week shortcut
 * @returns {Boolean}
 */
IcewarpDate.prototype.isThisWeek = function () {
	return this.isSame(new IcewarpDate(), 'week');
};
/**
 * Next week shortcut
 * @returns {Boolean}
 */
IcewarpDate.prototype.isNextWeek = function () {
	return this.isSame(new IcewarpDate().add(1, 'week'), 'week');
};
/**
 * this month shortcut
 * @returns {Boolean}
 */
IcewarpDate.prototype.isThisMonth = function () {
	return this.isSame(new IcewarpDate(), 'month');
};

/**
 * Check if date is before given date (custom implementation for non gragorian calandars)
 * @param {IcewarpDate} date
 * @param {string} type - is before what (day, month, year)
 * @returns {Boolean}
 */
IcewarpDate.prototype.isBefore = function (date, type) {
	if (this.calendar_type === Calendars.GREGORIAN) {
		return this.getMoment().isBefore(date.getMoment(), type);
	}
	switch (type) {
		case 'day':
			return this.format('YYYYMMDD') < date.format('YYYYMMDD');
		case 'month':
			return this.format('YYYYMM') < date.format('YYYYMM');
		case 'year':
			return this.format('YYYY') < date.format('YYYY');
	}
};

/**
 * Check if date is same as or before given date (custom implementation for non gragorian calandars)
 * @param {IcewarpDate} date
 * @param {string} type - is same or before what (day, month, year)
 * @returns {Boolean}
 */
IcewarpDate.prototype.isSameOrBefore = function (date, type) {
	if (this.calendar_type === Calendars.GREGORIAN) {
		return this.getMoment().isSameOrBefore(date.getMoment(), type);
	}
	switch (type) {
		case 'day':
			return this.format('YYYYMMDD') <= date.format('YYYYMMDD');
		case 'month':
			return this.format('YYYYMM') <= date.format('YYYYMM');
		case 'year':
			return this.format('YYYY') <= date.format('YYYY');
	}
};

/**
 * Check if date is after given date (custom implementation for non gragorian calandars)
 * @param {IcewarpDate} date
 * @param {string} type - is after what (day, month, year)
 * @returns {Boolean}
 */
IcewarpDate.prototype.isAfter = function (date, type) {
	if (this.calendar_type === Calendars.GREGORIAN) {
		return this.getMoment().isAfter(date.getMoment(), type);
	}
	switch (type) {
		case 'day':
			return this.format('YYYYMMDD') > date.format('YYYYMMDD');
		case 'month':
			return this.format('YYYYMM') > date.format('YYYYMM');
		case 'year':
			return this.format('YYYY') > date.format('YYYY');
	}
};

/**
 * Check if date is same as or after given date (custom implementation for non gragorian calandars)
 * @param {IcewarpDate} date
 * @param {string} type - is same or after (day, month, year)
 * @returns {Boolean}
 */
IcewarpDate.prototype.isSameOrAfter = function (date, type) {
	if (this.calendar_type === Calendars.GREGORIAN) {
		return this.getMoment().isSameOrAfter(date.getMoment(), type);
	}
	switch (type) {
		case 'day':
			return this.format('YYYYMMDD') >= date.format('YYYYMMDD');
		case 'month':
			return this.format('YYYYMM') >= date.format('YYYYMM');
		case 'year':
			return this.format('YYYY') >= date.format('YYYY');
	}
};

function addFnName(args, fn_name) {
	var new_args = [].slice.call(args);
	new_args.unshift(fn_name);
	return new_args;
}

(function alternativeCalendarPrefixerFactory() {
	var functions = ['millisecond', 'second', 'minute', 'hour', 'date', 'day', 'weekday', 'isoWeekday', 'dayOfYear', 'week', 'isoWeek', 'month', 'quarter', 'weekYear', 'isoWeekYear', 'weeksInYear', 'isoWeeksInYear', 'daysInMonth', 'fromNow', 'from', 'toNow', 'to', 'diff', 'unix', 'toDate', 'local', 'utcOffset'];
	functions.forEach(function (fn_name) {
		IcewarpDate.prototype[fn_name] = function () {
			return this.prefixedCaller.apply(this, addFnName(arguments, fn_name));
		};
	});
}());


IcewarpDate.Locale.chooseLocale('en');
typeof window !== 'undefined' && (window.IcewarpDate = IcewarpDate);
module.exports = IcewarpDate;

},{"./Calendars":41,"./Formats":42,"./Locale":44,"./PluginLoader":45,"moment":70,"moment-hijri":68,"moment-jalaali":69}],44:[function(require,module,exports){
/** @module Locale */
var Request = require('request');
var country_languages = require('@icewarp/country-language');
var Moment = require('moment');
var Calendars = require('./Calendars');

/**
 * changed start week
 * @type Boolean|number
 */
var custom_week_start = false;
var local_formats = ['L', 'LL', 'LLL', 'LLLL'];

var custom_localized_format = {};
var downloaded_locales = ['en'];
var locale_url = '';

/**
 * Icewarp special format for ovewriting
 * @param {number} id
 * @returns {undefined}
 */
function icewarpSpecialFormat(id) {
	switch (id) {
		case 0:
			return 'MM/DD/YY';
		case 1:
			return 'MM/DD/YYYY';
		case 2:
			return 'DD-MM-YYYY';
		case 3:
			return 'DD/MM/YYYY';
		case 4:
			return 'YYYY-MM-DD';
		case 5:
			return 'DD-MM-YY';
		case 6:
			return 'DD/MM/YY';
		case 7:
			return 'DD.MM.YY';
		case 8:
			return 'DD.MM.YYYY';
		case 9:
			return 'DD MMM YY';
		case 10:
			return 'DD MMM YYYY';
		default:
			return false;
	}
}

/** @module Locale */

/**
 * Prefix locale nale with alternative calendar prefix
 * @param {string} lang_code
 * @param {number} type
 * @returns {String}
 */
function prefixLocale(lang_code, type) {
	return Calendars.currentPrefix(type) ? (Calendars.currentPrefix(type) + '~' + lang_code) : lang_code;
}

/**
 * Try to resolve language code
 * @param {String} lang_code
 * @returns {String}
 */
function resolveLangCode(lang_code) {
	// todo parse more complex language codes like en-gb etc...
	if (country_languages[lang_code]) {
		return country_languages[lang_code].language;
	}
	console.warn('Wrong language code');
	return 'en';
}
/**
 * Create custom locale with user specific week start day and formats
 * @param {type} lang_code
 * @returns {createCustomLocale.custom|String}
 */
function createCustomLocale(lang_code) {
	var custom = lang_code + '~custom';
	if (Locale.locales[custom]) {
		Moment.locale(custom, null);
	}
	Locale.locales[custom] = 'custom-' + lang_code;
	var custom_locale = {parentLocale: lang_code};
	Object.keys(custom_localized_format).length && (custom_locale.longDateFormat = custom_localized_format);
	custom_week_start && (custom_locale.week = {
		dow: custom_week_start
	});
	var old_locale = Moment.locale() || 'en';
	Moment.defineLocale(custom, custom_locale);
	Moment.locale(old_locale);
	return custom;
}
/**
 * Create modified locale for alternative calendars
 * @param {string} lang_code
 * @param {number} [type] calendar type
 * @returns {undefined}
 */
function alternativeCalendarLocale(lang_code, type) {
	var _lang_code = prefixLocale(lang_code, type);
	if (Locale.locales[_lang_code]) {
		Moment.locale(_lang_code, null);
	}
	Locale.locales[_lang_code] = Locale.locales[lang_code] + '~' + Calendars.currentPrefix(type);
	var locale_data = Moment.localeData(lang_code);
	var old_locale = Moment.locale() || 'en';
	Moment.defineLocale(_lang_code, {
		parentLocale: lang_code,
		longDateFormat: (function () {
			var long_date_format = {};
			local_formats.forEach(function (format) {
				long_date_format[format] = Calendars.prefixFormat(locale_data.longDateFormat(format), type);
			});
			return long_date_format;
		}())
	});
	Moment.locale(old_locale);
	return _lang_code;
}
/**
 * Download locale file if necessary
 * @param {string} locale
 * @param {function} callback
 * @returns {unresolved}
 */
function downloadLocale(locale, callback) {
	if (~downloaded_locales.indexOf(locale)) {
		return callback();
	}
	var request = new Request({
		url: locale_url + locale + '.js',
		method: "GET"
	});
	request.on('load', function (event, response) {
		if(response.status === 404){
			return console.warn('Wrong language code');
		}
		var locale_fn = new Function(response.response);
		locale_fn.call({moment: Moment});
		downloaded_locales.push(locale);
		callback();
	});
	request.send();
}
/**
 * Static class for handling locale changes
 * @class Locale
 */
var Locale = {};

Locale.getIcewarpSpecificFormat = function(id){
	return icewarpSpecialFormat(id);
};

/**
 * Supported Locales
 * @type Object
 */
Locale.locales = require('./locales.json');

/**
 * Get access to Moment class
 * @returns {Moment}
 */
Locale.getMoment = function () {
	return Moment;
};

/**
 * Define new locale object
 * @param {string} lang_code language code
 * @param {Object} data new locale object @see http://momentjs.com/docs/#/i18n/changing-locale/
 * @returns {Locale}
 */
Locale.defineLocale = function (lang_code, data) {
	Moment.locale(lang_code, data);
	return this;
};
/**
 * Set locale download path
 * @param {string} url
 * @returns {Locale}
 */
Locale.setLocaleURL = function (url) {
	locale_url = url;
	return this;
};
/**
 * Choose locale
 * @param {string} lang_code
 * @param {IcewarpDate} [instance] specific instance
 * @returns {undefined}
 */
Locale.chooseLocale = function (lang_code, instance) {
	lang_code = Calendars.alterLocale(lang_code);
	Locale.lang = lang_code;
	lang_code = ~lang_code.indexOf('~') ? lang_code.split('~')[0] : lang_code; //get root locale
	if (!Locale.locales[lang_code]) {
		lang_code = resolveLangCode(lang_code);
	}
	downloadLocale(lang_code, function () {
		lang_code = createCustomLocale(lang_code);
		if (Calendars.currentPrefix(instance ? instance.calendar_type : false)) {
			lang_code = alternativeCalendarLocale(lang_code, instance ? instance.calendar_type : false);
		}
		Locale.lang_alt = lang_code;
		(instance ? instance.getMoment() : Moment).locale(lang_code);
	});
};

Locale.refreshLocale = function () {
	this.chooseLocale(this.lang);
};

/**
 * Delete defined locale
 * @param {string} lang_code
 * @returns {undefined}
 */
Locale.deleteLocale = function (lang_code) {
	Moment.locale(lang_code, null);
};
Locale.setCustomWeekStart = function (day_number) {
	custom_week_start = day_number;
};
/**
 * 
 * @param {string} target
 * @param {string} format
 * @returns {undefined}
 */
Locale.changeLocalizedFormat = function (target, format) {
	if (typeof format === 'number') {
		custom_localized_format[target] = icewarpSpecialFormat(format);
		return this;
	}
	custom_localized_format[target] = format;
	return this;
};

Locale.lang = 'en';
Locale.lang_alt = 'en';

module.exports = Locale;
},{"./Calendars":41,"./locales.json":47,"@icewarp/country-language":40,"moment":70,"request":"request"}],45:[function(require,module,exports){
/** @module PluginLoader */
var config = require('./config.json');
module.exports = function PluginLoader(){
	var plugins = {};
	config.plugins.forEach(function(plugin){
		plugins[plugin] = require(plugin);
	});
};
},{"./config.json":46}],46:[function(require,module,exports){
module.exports={
	"plugins": [

	]
}
},{}],47:[function(require,module,exports){
module.exports={
    "af": "Afrikaans",
    "ar-dz": "Arabic (Algeria)",
    "ar-kw": "Arabic (Kuwait)",
    "ar-ly": "Arabic (Lybia)",
    "ar-ma": "Arabic (Morocco)",
    "ar-sa": "Arabic (Saudi Arabia)",
    "ar-tn": "Arabic (Tunisia)",
    "ar": "Arabic",
    "az": "Azerbaijani",
    "be": "Belarusian",
    "bg": "Bulgarian",
    "bm": "Bambara",
    "bn": "Bengali",
    "bo": "Tibetan",
    "br": "Breton",
    "bs": "Bosnian",
    "ca": "Catalan",
    "cs": "Czech",
    "cv": "Chuvash",
    "cy": "Welsh",
    "da": "Danish",
    "de-at": "German (Austria)",
    "de-ch": "German (Switzerland)",
    "de": "German",
    "dv": "Maldivian",
    "el": "Greek",
    "en-au": "English (Australia)",
    "en-ca": "English (Canada)",
    "en-gb": "English (United Kingdom)",
    "en-ie": "English (Ireland)",
    "en-nz": "English (New Zealand)",
    "eo": "Esperanto",
    "es-do": "Spanish (Dominican Republic)",
    "es-us": "Spanish(United State)",
    "es": "Spanish",
    "et": "Estonian",
    "eu": "Basque",
    "fa": "Persian",
    "fi": "Finnish",
    "fo": "Faroese",
    "fr-ca": "French (Canada)",
    "fr-ch": "French (Switzerland)",
    "fr": "French",
    "fy": "Frisian",
    "gd": "Scottish Gaelic",
    "gl": "Galician",
    "gom-latn": "Konkani Latin script",
    "gu": "Gujarati",
    "he": "Hebrew",
    "hi": "Hindi",
    "hr": "Croatian",
    "hu": "Hungarian",
    "hy-am": "Armenian",
    "id": "Indonesian",
    "is": "Icelandic",
    "it": "Italian",
    "ja": "Japanese",
    "jv": "Javanese",
    "ka": "Georgian",
    "kk": "Kazakh",
    "km": "Cambodian",
    "kn": "Kannada",
    "ko": "Korean",
    "ky": "Kyrgyz",
    "lb": "Luxembourgish",
    "lo": "Lao",
    "lt": "Lithuanian",
    "lv": "Latvian",
    "me": "Montenegrin",
    "mi": "Maori",
    "mk": "Macedonian",
    "ml": "Malayalam",
    "mr": "Marathi",
    "ms-my": "Malay",
    "ms": "Malay",
    "my": "Burmese",
    "nb": "Norwegian Bokml",
    "ne": "Nepalese",
    "nl-be": "Dutch (Belgium)",
    "nl": "Dutch",
    "nn": "Nynorsk",
    "pa-in": "Punjabi (India)",
    "pl": "Polish",
    "pt-br": "Portuguese (Brazil)",
    "pt": "Portuguese",
    "ro": "Romanian",
    "ru": "Russian",
    "sd": "Sindhi",
    "se": "Northern Sami",
    "si": "Sinhalese",
    "sk": "Slovak",
    "sl": "Slovenian",
    "sq": "Albanian",
    "sr-cyrl": "Serbian Cyrillic",
    "sr": "Serbian",
    "ss": "siSwati",
    "sv": "Swedish",
    "sw": "Swahili",
    "ta": "Tamil",
    "te": "Telugu",
    "tet": "Tetun Dili (East Timor)",
    "th": "Thai",
    "tl-ph": "Tagalog (Philippines)",
    "tlh": "Klingon",
    "tr": "Turkish",
    "tzl": "Talossan",
    "tzm-latn": "Central Atlas Tamazight Latin",
    "tzm": "Central Atlas Tamazight",
    "uk": "Ukrainian",
    "ur": "Urdu",
    "uz-latn": "Uzbek Latin",
    "uz": "Uzbek",
    "vi": "Vietnamese",
    "x-pseudo": "Pseudo",
    "yo": "Yoruba Nigeria",
    "zh-cn": "Chinese (China)",
    "zh-hk": "Chinese (Hong Kong)",
    "zh-tw": "Chinese (Taiwan)",
    "en": "English"
}
},{}],48:[function(require,module,exports){
/**
 * map of substitutions
 */
var entity_map = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#39;',
	'/': '&#x2F;',
	'`': '&#x60;',
	'=': '&#x3D;'
};

/**
 * function to escape &<>"'`=\/ in string
 * @param string string to escape
 */
var escapeString = function(string) {
	return String(string).replace(/[&<>"'`=/]/g, function (match) {
		return entity_map[match];
	});
};

/**
 * @module escape-string
 */
module.exports = escapeString;

},{}],49:[function(require,module,exports){
var Request = require('request');
var logger = require('logger');
var Polyglot = require('./polyglot.js');
var polyglot = null;

/**
 * object to store loaded languages
 */
var language_dictionaries = {};
/**
 * object to store supported languages
 */
var supported_languages = {
	en: {
		direction: 'ltr',
		label: 'English'
	}
};

/**
 * i18n settings
 */
var settings = {};

var default_locale = 'en';

/**
 * 
 * @param {function} fn
 * @param {string} language
 * @param {Event} event
 * @param {XmlHttpRequest} xhr
 * @returns {i18n}
 */
var loadSuccess = function (fn, language, event, xhr) {
	try {
		language_dictionaries[language] = JSON.parse(event.target.responseText);
	} catch (e) {
		//
	}

	polyglot.extend(language_dictionaries[default_locale]);
	polyglot.extend(language_dictionaries[language]);
	polyglot.locale(language);
	fn(language);
	return this;
};

/**
 * 
 * @param {string} error_message
 * @param {function} fn
 * @param {string} language
 * @param {XmlHttpRequest} xhr
 * @returns {unresolved}
 */
var loadError = function (error_message, fn, language, xhr) {
	polyglot.locale(language);
	return fn ? fn(polyglot.locale()) : logger.error(error_message);
};

function compareVersions(a, b) {
	return compareVersions.parts(a.split('.'), b.split('.'), 0);
}
compareVersions.parts = function (a_parts, b_parts, index) {
	var diff;
	return ((a_parts.length - 1) < index && (b_parts.length - 1) < index) ? 0 : (!(diff = (+a_parts[index] || 0) - (+b_parts[index] || 0)) ? compareVersions.parts(a_parts, b_parts, index + 1) : (diff < 0 ? -1 : 1));
};

/**
 * Class for frontend translations
 * @class i18n
 */
function i18n() {}

/**
 * Initialize i18n library
 * @param {object} options
 * @param {string} url - url of local dictionaries
 * @param {string} [default_locale] - ISO code of default locale
 * @param {string} [external_url] - url of external dictionaries (required for external dictionaries)
 * @param {Object} [default_locale_dictionary] - dictionary that is build in application
 * @param {string} [version] - version of local dictionaries (required for external dictionaries)
 * @param {string} [project_name] - name of project (required for external dictionaries)
 * @param {boolean} [options.dynamic] - switches translate function from regular to dynamic
 * @param {function} [callback] - callback function called on i18n initialization
 * @returns {i18n}
 */
i18n.init = function (options, callback) {
	settings = options || {};
	polyglot = new Polyglot(settings);

	if (settings.default_locale) {
		default_locale = settings.default_locale;
		if (settings.default_locale_dictionary) {
			language_dictionaries[settings.default_locale] = settings.default_locale_dictionary;
		}
	}

	supported_languages = settings.supported_languages || supported_languages;
	checkExternalDictionary.call(this, function () {
		i18n.changeLanguage(default_locale, callback);
	});

	settings.expose && (window[settings.expose] = (settings.dynamic ? i18n.tDynamic : i18n.tRegular).bind(i18n));
};

i18n.getSupportedLanguages = function () {
	return supported_languages;
};

/**
 * @summary Check and download external dictionary, if it's missing or it's old fallback to local
 * @description First check if settings necessary for external loading are present. Then create request for remote dictionary version, compare this version with settings.version this property contains version of locale dictionary from app build process. If external version is higher than local download external dictionary and save that external version for that language so it's not checked another time and fallback directly to error handler. Error handler checks if there is dictionary already in memory so there will be no other xhr. 
 * @param {function} callback
 * @returns {undefined}
 */
function checkExternalDictionary(callback) {
	if (!settings.external_url || !settings.version) {
		logger.info('Missing settings for external dictionary');
		return callback();
	}

	this.download(settings.external_url + '/version.json', function (event) {
		var version;
		try {
			version = JSON.parse(event.target.responseText).version;
		} catch (error) {
			return callback();
		}
		if (compareVersions(version, settings.version) === 1) {
			settings.url = settings.external_url;
			this.download(settings.url + '/languages.json', function (event) {
				try {
					supported_languages = JSON.parse(event.target.responseText);
				} catch (e) {
					//
				}
				language_dictionaries = {};
				callback();
			}.bind(this));
		} else {
			callback();
		}
	}.bind(this), callback);
}

i18n.download = function (url, success, error) {
	var options = {
		url: url
	};
	new Request(options)
		.on('load', success)
		.on('error', error)
		.send();
};

function downloadDictionary(url, language, fn, error_fn) {
	fn = fn || function () {};
	error_fn = error_fn || fn;
	this.download(url, loadSuccess.bind(this, fn, language), loadError.bind(this, error_fn, language));
}

/**
 * Change output language. Automatically loads new language file if not loaded yet
 * @param {string} language
 * @param {function} fn
 * @param {function} error_fn
 * @returns {i18n}
 */
i18n.changeLanguage = function (language, fn, error_fn) {
	if (!supported_languages[language]) {
		return loadError.call(this, language + ' language not supported', error_fn || fn, language);
	}

	if (language_dictionaries[language]) {
		polyglot.extend(language_dictionaries[default_locale]);
		polyglot.extend(language_dictionaries[language]);
		polyglot.locale(language);
		fn && fn(language);
		return;
	}
	downloadDictionary.call(this, settings.url + '/' + language + '.json', language, fn, error_fn);
	return this;
};

/**
 * function to translate text
 * 
 * @returns {string}
 */
i18n.tRegular = function () {
	return polyglot.t.apply(polyglot, arguments);
};

/**
 * function to translate text, returns new lambda that will return translated string
 * 
 * @returns {function}
 */
i18n.tDynamic = function () {
	var args = arguments;
	return function () {
		return polyglot.t.apply(polyglot, args);
	};
};

i18n.t = i18n.tRegular;

/** 
 * @module @icewarp/i18n 
 * @requires @icewarp/request
 * @requires @icewarp/logger
 * @requires node-polyglot
 */
module.exports = i18n;

},{"./polyglot.js":51,"logger":"logger","request":"request"}],50:[function(require,module,exports){
/**
 * function to parse MD syntax
 * @param input input text to parse
 */
module.exports = function (input) {
	return input.replace(/(\*{1,2}|_{1,2})(.*?)\1/gi, function (match, m1, m2) {
		var tag = ['em', 'strong'][m1.length - 1];
		return '<' + tag + '>' + m2 + '</' + tag + '>';
	}).replace(/\[(.*?)\]\((.*?)\)/gi, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
};
},{}],51:[function(require,module,exports){
var logger = require('logger');
var Escape = require('@icewarp/escape-string');
var markdown = require('./markdown.js');
/**
 * Polyglot dictionary
 */
var phrases = {};
/**
 * Supress errors on missing translation
 * @type Boolean
 */
var allowMissing = false;
/**
 * Current locale
 * @type String
 */
var current_locale = '';
/**
 * Current plural type function
 * @type function
 */
var current_plural_type = null;
/**
 * Plural forms delimiter
 * @type String
 */
var delimiter = '||||';

var start_tag = '%{';

var end_tag = '}';

/**
 * Types of plural
 */
var pluralTypes = {
	chinese: function (n) {
		return 0;
	},
	german: function (n) {
		return n !== 1 ? 1 : 0;
	},
	french: function (n) {
		return n > 1 ? 1 : 0;
	},
	russian: function (n) {
		return n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
	},
	czech: function (n) {
		return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
	},
	polish: function (n) {
		return (n === 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	},
	icelandic: function (n) {
		return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0;
	}
};

/**
 * List of languages for each plural type
 */
var pluralTypeToLanguages = {
	chinese: ['fa', 'id', 'ja', 'ko', 'lo', 'ms', 'th', 'tr', 'zh'],
	german: ['da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hu', 'it', 'nl', 'no', 'pt', 'sv'],
	french: ['fr', 'tl', 'pt-br'],
	russian: ['hr', 'ru'],
	czech: ['cs', 'sk'],
	polish: ['pl'],
	icelandic: ['is']
};

/**
 * Return type of plural for locale
 * @param {String} locale
 * @returns {String}
 */
function pluralType(locale) {
	for (var type in pluralTypeToLanguages) {
		if (~pluralTypeToLanguages[type].indexOf(locale)) {
			return type;
		}
	}
	return 'german';
}

/**
 * Return index of plural form for count
 * @param {Number} count
 * @returns {Number}
 */
function pluralIndex(count) {
	return pluralTypes[current_plural_type](count);
}

/**
 * Return plural translation for text specified by count
 * @param {String} text
 * @param {Number} count
 * @returns {String}
 */
function plural(text, count) {
	var texts = text.split(delimiter);
	return (texts[pluralIndex(count)] || texts[0]).trim();
}

/**
 * Substitute %{placeholder}'s for options[placeholder]'s
 * @param {String} phrase
 * @param {Object} options
 * @returns {String}
 */
function substitute(phrase, options) {
	if (Array.isArray(options)) {
		var _options = {};
		options.forEach(function (value, index) {
			_options[index] = value;
		});
		options = _options;
	}
	phrase = (options.md === void 0 || options.md) ? markdown(phrase) : phrase;
	var escape = options.escape === void 0 ? true : options.escape;
	delete(options.md);
	delete(options.escape);
	for (var arg in options) {
		phrase = phrase.replace(new RegExp(start_tag + arg + end_tag, 'g'), escape ? Escape(options[arg]) : options[arg]);
	}
	var substitution_index = 0;
	phrase = phrase.replace(/%s/g, function () {
		return options[substitution_index++];
	});
	return phrase;
}

/**
 * Polyglot class
 * @param {Object} options
 * @returns {Polyglot}
 */
function Polyglot(options) {
	options = options || {};
	allowMissing = !!options.allowMissing;
	options.delimiter && (delimiter = options.delimiter);
	options.start_tag && (start_tag = options.start_tag);
	options.end_tag && (end_tag = options.end_tag);
	this.locale(options.default_locale || 'en');
	this.extend(options.default_locale_dictionary || {});
}

/**
 * Get and/or set current_locale
 * @param {type} new_locale
 * @returns {String} current_locale
 */
Polyglot.prototype.locale = function (new_locale) {
	new_locale && (current_locale = new_locale) && (current_plural_type = pluralType(current_locale));
	return current_locale;
};

/**
 * Extend polyglot dictionary with morePhrases
 * @param {Object} morePhrases
 * @returns {Polyglot}
 */
Polyglot.prototype.extend = function (morePhrases) {
	for (var key in morePhrases) {
		var phrase = morePhrases[key];
		var prefixedKey = (arguments[1] || '') + key;
		if (typeof phrase === 'object') {
			this.extend(phrase, prefixedKey + '.');
		} else {
			phrases[prefixedKey] = phrase;
		}
	}
	return this;
};

/**
 * Translate function
 * @param {String} key
 * @param {Object} options
 * @returns {String}
 */
Polyglot.prototype.t = function (key, options, fallback) {
	options = (options === null || options === void 0) ? {} : (typeof options === 'number' ? {amount: options} : options);
	if (typeof phrases[key] !== 'string') {
		switch (typeof fallback) {
			case 'function':
				return fallback(key, options);
			case 'string':
				return fallback;
		}
		phrases[key] = key;
		allowMissing || logger.warning('Missing translation for key: "' + key + '"');
	}
	return substitute(plural(phrases[key], options.amount === void 0 ? 1 : (+options.amount || 1)), options);
};

/**
 * @module Polyglot
 */
module.exports = Polyglot;

},{"./markdown.js":50,"@icewarp/escape-string":48,"logger":"logger"}],52:[function(require,module,exports){
/**
 * Options for IQ setup.
 * @typedef {Object} IQOptions
 * @property {array} arguments - array of arguments to be addet to IQ tag (Optional).
 * @property {string} id_attr - Custom rename of ID attribute (optional).
 * @property {string} format - Change format of response (optional).
 */

/**
 * Messages ID auto increment
 * @type Number
 */
var i = 1;
/**
 * Crate IQ message and handle response for it.
 * @class IQ
 * @param {IQOptions} options
 * @returns {IQ}
 */
function IQ(options) {
	options = options || {};
	/**
	 * IQ callbacks storage
	 * @type object
	 */
	this.iqs = {};
	/**
	 * Arguments to add to IQ
	 * @type Array
	 */
	this.arguments = options.arguments || [];
	/**
	 * Custom rename of ID attribute
	 * @type string
	 */
	this.id_attr = options.id_attr || 'id';
	/**
	 * Change type of response
	 * @type string
	 */
	this.format = options.format || 'text/xml';
	
	this.id = i++;
}
/**
 * Add attribute to IQ tag
 * @param {string} name
 * @param {*} value
 * @returns {undefined}
 */
IQ.prototype.addAttribute = function (name, value) {
	this.arguments.push({name: name, value: value});
	return this;
};
/**
 * Create IQ message, auto increment ID and save callbacks
 * @param {string} body
 * @param {object} callback
 * @returns {String}
 */
IQ.prototype.getIQ = function (body, callback) {
	this.iqs[this.id] = callback;
	return "<iq " + this.id_attr + '="' + this.id + '" ' + (this.arguments.map(function (argument) {
		return argument.name + '="' + argument.value + '" ';
	}).join(' ')) + " format=\"" + this.format + "\"><query " + (this.query.arguments.map(function (argument) {
		return argument.name + '="' + argument.value + '" ';
	}).join(' ')) + ">" + body + "</query></iq>";
};
/**
 * Process response and return callbacks by ID
 * @param {string} response
 * @returns {object}
 */
IQ.prototype.getCallbacks = function (response, id) {
	var xml = new DOMParser().parseFromString(response.replace(/>\s+</g, '><'), "text/xml");
	var iq;
	var callback;
	if ((iq = xml.getElementsByTagName('iq')).length) {
		callback = this.iqs[id || iq[0].getAttribute(this.id_attr)];
		delete this.iqs[id || iq[0].getAttribute(this.id_attr)];
		return {callback: callback, document: xml};
	}
	throw new Error("Malformed message");
};
/**
 * Get IQ by it's ID
 * @param {number} id
 * @returns {object}
 */
IQ.prototype.getCallbacksById = function (id) {
	return this.iqs[id];
};
/**
 * Get All pending IQs
 * @returns {object}
 */
IQ.prototype.getPendingIqs = function () {
	return this.iqs;
};
IQ.prototype.query = {
	arguments: [],
	addAttribute: function (name, value) {
		this.arguments.push({name: name, value: value});
		return this;
	}
};

module.exports = IQ;

},{}],53:[function(require,module,exports){
/**
 * @class Json
 */
var Json = {};

/**
 * Converts JSON object to XML string
 * @param {object} json
 * @returns {string} XML string
 */
Json.toXmlString = function(json) {
	if (Array.isArray(json)) {
		return json.map(function (item) {
			return this.toXmlString(item);
		}, this).join('');
	} else if (typeof json === 'object') {
		return Object.keys(json).map(function (key) {
			return '<' + key + '>' + this.toXmlString(json[key]) + '</' + key + '>';
		}, this).join('');
	}
	return json;
};

/**
 * Converts JSON object to XML object
 * @param {object} json
 * @returns {object} xml
 */
Json.toXml = function(json) {
	return this.XmlStringToXml(this.toXmlString(json));
};

/**
 * Parses XML string to XML
 * @param {string} xml xml string
 * @returns {object} XML
 */
Json.XmlStringToXml = function(xml) {
	return (new DOMParser()).parseFromString(xml, "text/xml");
};

/**
 * Converts XML to JSON
 * @param {object} xml
 * @returns {object} converted json
 */
Json.fromXml = function(xml) {
	var obj = {};

	if (xml.nodeType === 3 || (!(xml.attributes || []).length && !xml.hasChildNodes())) {
		return xml.nodeValue;
	}
	
	if ((xml.attributes || []).length > 0) {
		obj._attributes = {};
		for (var j = 0; j < xml.attributes.length; j++) {
			var attribute = xml.attributes.item(j);
			obj._attributes[attribute.nodeName] = attribute.nodeValue;
		}
	}

	for (var i = 0; i < (xml.childNodes || []).length; i++) {
		var item = xml.childNodes.item(i);
		var nodeName = item.nodeName;
		if (nodeName === '#text') {
			if(typeof obj === 'string') {
				obj += this.fromXml(item);
			} else {
				obj = this.fromXml(item);
			}
		} else if (obj[nodeName] === void 0) {
			obj[nodeName] = this.fromXml(item);
		} else {
			if (obj[nodeName].push === void 0) {
				var old = obj[nodeName];
				obj[nodeName] = [];
				obj[nodeName].push(old);
			}
			obj[nodeName].push(this.fromXml(item));
		}
	}
	return obj;
};

/**
 * Converts XML string to JSON
 * @param {type} xml
 * @returns {unresolved}
 */
Json.fromXmlString = function(xml) {
	return this.fromXml(this.XmlStringToXml(xml));
};

/**
 * @module Json
 */
module.exports = Json;

},{}],54:[function(require,module,exports){
function migrate() {
	for (var i = 0; i < localStorage.length; i++) {
		var key = localStorage.key(i);
		fakeEngine.setItem(key, localStorage.getItem(key));
	}
}

var fakeStorage = {};
var fakeEngine = {};

fakeEngine.getItem = function (key) {
	return fakeStorage[key];
};
fakeEngine.setItem = function (key, value) {
	fakeStorage[key] = value;
};
fakeEngine.removeItem = function (key) {
	delete(fakeStorage[key]);
};

var LocalStorage = {};
LocalStorage.getItem = function (key) {
	var value = _engine.getItem(key);
	try {
		return JSON.parse(value);
	} catch (e) {
		return value;
	}
};
LocalStorage.setItem = function (key, value) {
	try {
		_engine.setItem(key, JSON.stringify(value));
	} catch (e) {
		if (~['QUOTA_EXCEEDED_ERR', 'NS_ERROR_DOM_QUOTA_REACHED'].indexOf(e.name) || ~e.toString().indexOf("QUOTA_EXCEEDED_ERR") || ~e.toString().indexOf("QuotaExceededError")) {
			_engine = fakeEngine;
			migrate();
			return this.set(key, value);
		}
	}
	return this;
};
LocalStorage.removeItem = function (key) {
	_engine.removeItem(key);
	return this;
};

LocalStorage.setEngine = function (engine) {
	if(!engine.getItem) {
		throw new Error('Engine is missing getItem function');
	}
	if(!engine.setItem) {
		throw new Error('Engine is missing setItem function');
	}
	if(!engine.removeItem) {
		throw new Error('Engine is missing removeItem function');
	}
	_engine = engine;
};

var _engine = fakeEngine;
try {
	localStorage.setItem('_privateSafari', 'sucks');
	_engine = localStorage;
	localStorage.removeItem('_privateSafari');
} catch (e) {
	console.log('safari private');
}
module.exports = LocalStorage;

},{}],55:[function(require,module,exports){
var IQ = require('@icewarp/iq-protocol');
var Json = require('@icewarp/json-xml');
var processResponse = require('./processResponse');
var connections = {};
var main = 'default';

function createConnection(type) {
	this.setConnection(new OldCommunication.connections[type](this.getOptions()));
}
/**
 * @class OldCommunication
 * @param {number} type type of connection XHR|Scoket
 * @param {string} name will be used as ke for storing this instance in global storage
 * @param {object} options
 * @returns {OldCommunication}
 */
function OldCommunication(type, name, options) {
	this.host = options.host;
	this.email = options.email;
	this.subscriptions = options.subscriptions || [];
	this.password = options.password;
	this.login_type = options.login_type || OldCommunication.PLAIN;
	this.send_type = options.send_type || OldCommunication.XML;
	options.iq_options = options.iq_options || {};
	options.iq_options.id_attr = options.iq_options.id_attr || 'uid';
	this.iq = new IQ(options.iq_options);
	this.iq.query.addAttribute('xmlns', options.xmlns || "admin:iq:rpc");
	options.session_id && this.iq.addAttribute('sid', options.session_id);
	createConnection.call(this, type);
	connections[name || main] = this;
}
/**
 * @constant
 * XHR connection
 */
OldCommunication.XHR = 1;
/**
 * @constant
 * Socket connection
 */
OldCommunication.SOCKET = 2;
/**
 * @type {object}
 * @static
 * @description List of connection libs
 */
OldCommunication.connections = {};
OldCommunication.connections[OldCommunication.XHR] = require('@icewarp/xhr-connection');
OldCommunication.connections[OldCommunication.SOCKET] = require('socket');

/**
 * @constant
 * Plain auth const
 */
OldCommunication.PLAIN = 1;
/**
 * @constant
 * Auth via RSA digest
 */
OldCommunication.DIGEST = 2;

OldCommunication.XML = 'xml';

/**
 * @static
 * @type {object}
 * Error types
 */
OldCommunication.ERRORS = {
	UNSPECIFIED: 'unspecified',
	SERVER: 'server'
};

OldCommunication.prototype.callback = require('Callback');

OldCommunication.prototype.getOptions = function () {
	return {
		protocol: "xmpp",
		listeners: {
			onopen: {
				func: processResponse.onOpen,
				context: this
			},
			onclose: {
				func: processResponse.onClose,
				context: this
			},
			onerror: {
				func: processResponse.onError,
				context: this
			},
			onmessage: {
				func: processResponse.onMessage,
				context: this
			}
		},
		host: this.host
	};
};

/**
 *
 * @param {object} json
 * @param {@icewarp/Callback} callback
 * @returns {undefined}
 */
OldCommunication.prototype.send = function (json, callback) {
	this.connection.send(this.iq.getIQ(Json.toXmlString(json), callback), this.iq.id);
};
/**
 * Set chosen connection instance
 * @param {Xhr|Socket} connection
 * @returns {Xhr|Socket}
 */
OldCommunication.prototype.setConnection = function (connection) {
	return this.connection = connection;
};
/**
 * get OldCommunication from global storage
 * @param {string} name
 * @returns {OldCommunication}
 */
OldCommunication.getConnection = function (name) {
	if (!connections[name || main]) {
		throw new Error("Missing connection : " + name);
	}
	return connections[name || main];
};

module.exports = OldCommunication;

},{"./processResponse":56,"@icewarp/iq-protocol":52,"@icewarp/json-xml":53,"@icewarp/xhr-connection":63,"Callback":"Callback","socket":"socket"}],56:[function(require,module,exports){
var Json = require('@icewarp/json-xml');
var processResponse = {};

function processData(message) {
	var response = Json.fromXml(message.document.querySelector('iq'));
	if (response._attributes.type === 'error' || response.query.result === '0') {
		return this.callback(
			'error',
			message.callback,
			((response.query.error || {})._attributes || {}).uid || this.constructor.ERRORS.UNSPECIFIED,
			response
		);
	}
	this.callback('success', message.callback, response.query.result, response);
}

processResponse.onMessage = function (data, id) {
	processData.call(this, this.iq.getCallbacks(data, id));
};
processResponse.onError = function (id) {
	var iqs = [];
	if (id) {
		iqs = [this.iq.getCallbacksById(id)];
	} else {
		var iqs_obj = this.iq.getPendingIqs();
		for (var i in iqs_obj) {
			iqs.push(iqs_obj[i]);
		}
	}
	iqs.forEach(function (callback) {
		this.callback('error', callback, this.constructor.ERRORS.SERVER);
	}, this);
};
processResponse.onClose = function () {

};
processResponse.onOpen = function () {

};

module.exports = processResponse;

},{"@icewarp/json-xml":53}],57:[function(require,module,exports){
var StringUtils = require('./string.js');
var Utils = {};

var supress_animations = false;
/**
 * Supress animations
 */
Utils.supress = function () {
	document.body.classList.add('no-animation');
	supress_animations = true;
};

/**
 * Allow animations
 */
Utils.allow = function () {
	document.body.classList.remove('no-animation');
	supress_animations = false;
};

/**
 * Returns whether animations are enabled
 * @returns {Boolean}
 */
Utils.allowed = function () {
	return !supress_animations;
};

/**
 * Return supported browser event type
 * @param {String} event
 * @returns {String|Boolean} Supported event type or false
 */
Utils.browserEvent = function (event) {
	if (!this.allowed()) {
		return false;
	}
	if (('on' + event) in window || event.replace(/end|start|update$/, '') in document.body.style) {
		return event;
	}
	if (('onwebkit' + event) in window) {
		return 'webkit' + StringUtils.capitalize(event[0]).replace(/(end|start|update)$/, StringUtils.capitalize);
	}
	return false;
};

module.exports = Utils;
},{"./string.js":61}],58:[function(require,module,exports){
var Utils = {};

/**
 * Detect if the browser is IE 9+
 * @returns {Boolean}
 */
Utils.isIE = function () {
	return !!(window.ActiveXObject || "ActiveXObject" in window);
};

/**
 * Detect if the browser is MS Edge
 * @returns {Boolean}
 */
Utils.isEdge = function () {
	return !Utils.isIE() && !!window.StyleMedia;
};

module.exports = Utils;
},{}],59:[function(require,module,exports){
var Utils = {};

/**
 * Push items from arr array to data object
 * @param {*} data
 * @param {*} arr
 * @returns {Utils.push.data}
 */
Utils.push = function (data, arr) {
	data = data || [];
	[].push.apply(data, Array.isArray(arr) ? arr : [arr]);
	data = data.filter(function (value, index) {
		return value !== void 0 && data.indexOf(value) === index;
	});
	return data;
};

/**
 * Push items from arr array to data property
 * @param {Object} data
 * @param {String} property
 * @param {*} arr
 * @returns {Array}
 */
Utils.pushToProperty = function (data, property, arr) {
	if (data === void 0) {
		return data;
	}
	data[property] = data[property] || [];
	[].push.apply(data[property], Array.isArray(arr) ? arr : [arr]);
	data[property] = data[property].filter(function (value, index) {
		return value !== void 0 && data[property].indexOf(value) === index;
	});
	return data;
};

Utils.splice = function (array, item) {
	if (!Array.isArray(array)) {
		return false;
	}
	if (Array.isArray(item)) {
		return item.forEach(function (i) {
			Utils.splice(array, i);
		});
	}
	array.splice(array.indexOf(item), 1);
};

module.exports = Utils;
},{}],60:[function(require,module,exports){
var Utils = {};

Utils.enabled = function () {
	return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
};

Utils.element = function () {
	return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
};

Utils.exit = function () {
	(document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen || function () {}).bind(document)();
};

Utils.request = function (element) {
	(element.requestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen || element.msRequestFullscreen || function () {}).bind(element)();
};

module.exports = Utils;
},{}],61:[function(require,module,exports){
var Utils = {};

/**
 * Capitalize string
 * @param {String} string
 * @returns {String} capitalized string
 */
Utils.capitalize = function (string) {
	return string[0].toUpperCase() + string.slice(1);
};

module.exports = Utils;
},{}],62:[function(require,module,exports){
var Utils = {};

Utils.animations = require('./src/animations.js');
Utils.browser = require('./src/browser.js');
Utils.data = require('./src/data.js');
Utils.fullscreen = require('./src/fullscreen.js');
Utils.string = require('./src/string.js');

module.exports = Utils;
},{"./src/animations.js":57,"./src/browser.js":58,"./src/data.js":59,"./src/fullscreen.js":60,"./src/string.js":61}],63:[function(require,module,exports){
var Request = require('request');

function onLoad(id, event, response) {
	this.onMessage && this.onMessage.func.call(this.onMessage.context || this, response.response || response.responseText, id);
}
function onError(id, event, response) {
	this.onError && this.onError.func.call(this.onError.context || this, id);
}

function XHRConnection(options) {
	options.listeners = options.listeners || {};
	this.onMessage = options.listeners.onmessage;
	this.onError = options.listeners.onerror;
	this.host = options.host;
}

XHRConnection.prototype.send = function (payload, id) {
	var request = new Request({
		url: this.host,
		method: "POST"
	});
	request.on('load', onLoad.bind(this, id));
	request.on('error', onError.bind(this, id));
	request.on('abort', onError.bind(this, id));
	request.send(payload);
};

module.exports = XHRConnection;

},{"request":"request"}],64:[function(require,module,exports){
/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20170427
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in window.self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_")) 
	|| document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = view.Element[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.setAttribute("class", this.toString());
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
		, index
	;
	do {
		token = tokens[i] + "";
		index = checkTokenAndGetIndex(this, token);
		while (index !== -1) {
			this.splice(index, 1);
			updated = true;
			index = checkTokenAndGetIndex(this, token);
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, force) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			force !== true && "remove"
		:
			force !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	if (force === true || force === false) {
		return force;
	} else {
		return !result;
	}
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		// adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
		// modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
		if (ex.number === undefined || ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(window.self));

}

// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
	"use strict";

	var testElement = document.createElement("_");

	testElement.classList.add("c1", "c2");

	// Polyfill for IE 10/11 and Firefox <26, where classList.add and
	// classList.remove exist but support only one argument at a time.
	if (!testElement.classList.contains("c2")) {
		var createMethod = function(method) {
			var original = DOMTokenList.prototype[method];

			DOMTokenList.prototype[method] = function(token) {
				var i, len = arguments.length;

				for (i = 0; i < len; i++) {
					token = arguments[i];
					original.call(this, token);
				}
			};
		};
		createMethod('add');
		createMethod('remove');
	}

	testElement.classList.toggle("c3", false);

	// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	// support the second argument.
	if (testElement.classList.contains("c3")) {
		var _toggle = DOMTokenList.prototype.toggle;

		DOMTokenList.prototype.toggle = function(token, force) {
			if (1 in arguments && !this.contains(token) === !force) {
				return force;
			} else {
				return _toggle.call(this, token);
			}
		};

	}

	testElement = null;
}());

}

},{}],65:[function(require,module,exports){
'use strict';

require('./index').polyfill();

},{"./index":66}],66:[function(require,module,exports){
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */

'use strict';

function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};

},{}],67:[function(require,module,exports){
/*
  Expose functions.
*/
module.exports =
  { toJalaali: toJalaali
  , toGregorian: toGregorian
  , isValidJalaaliDate: isValidJalaaliDate
  , isLeapJalaaliYear: isLeapJalaaliYear
  , jalaaliMonthLength: jalaaliMonthLength
  , jalCal: jalCal
  , j2d: j2d
  , d2j: d2j
  , g2d: g2d
  , d2g: d2g
  }

/*
  Jalaali years starting the 33-year rule.
*/
var breaks =  [ -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210
  , 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178
  ]

/*
  Converts a Gregorian date to Jalaali.
*/
function toJalaali(gy, gm, gd) {
  if (Object.prototype.toString.call(gy) === '[object Date]') {
    gd = gy.getDate()
    gm = gy.getMonth() + 1
    gy = gy.getFullYear()
  }
  return d2j(g2d(gy, gm, gd))
}

/*
  Converts a Jalaali date to Gregorian.
*/
function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd))
}

/*
  Checks whether a Jalaali date is valid or not.
*/
function isValidJalaaliDate(jy, jm, jd) {
  return  jy >= -61 && jy <= 3177 &&
          jm >= 1 && jm <= 12 &&
          jd >= 1 && jd <= jalaaliMonthLength(jy, jm)
}

/*
  Is this a leap year or not?
*/
function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0
}

/*
  Number of days in a given month in a Jalaali year.
*/
function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) return 31
  if (jm <= 11) return 30
  if (isLeapJalaaliYear(jy)) return 30
  return 29
}

/*
    This function determines if the Jalaali (Persian) year is
    leap (366-day long) or is the common year (365 days)

    @param jy Jalaali calendar year (-61 to 3177)
    @returns number of years since the last leap year (0 to 4)
 */
function jalCalLeap(jy) {  
  var bl = breaks.length        
    , jp = breaks[0]
    , jm
    , jump
    , leap    
    , n
    , i

  if (jy < jp || jy >= breaks[bl - 1])
    throw new Error('Invalid Jalaali year ' + jy)
    
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i]
    jump = jm - jp
    if (jy < jm)
      break    
    jp = jm
  }
  n = jy - jp
  
  if (jump - n < 6)
    n = n - jump + div(jump + 4, 33) * 33
  leap = mod(mod(n + 1, 33) - 1, 4)
  if (leap === -1) {
    leap = 4
  }  
 
  return leap
}

/*
  This function determines if the Jalaali (Persian) year is
  leap (366-day long) or is the common year (365 days), and
  finds the day in March (Gregorian calendar) of the first
  day of the Jalaali year (jy).

  @param jy Jalaali calendar year (-61 to 3177)
  @param withoutLeap when don't need leap (true or false) default is false
  @return
    leap: number of years since the last leap year (0 to 4)
    gy: Gregorian year of the beginning of Jalaali year
    march: the March day of Farvardin the 1st (1st day of jy)
  @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
  @see: http://www.fourmilab.ch/documents/calendar/
*/
function jalCal(jy, withoutLeap) {  
  var bl = breaks.length
    , gy = jy + 621
    , leapJ = -14
    , jp = breaks[0]
    , jm
    , jump
    , leap
    , leapG
    , march
    , n
    , i

  if (jy < jp || jy >= breaks[bl - 1])
    throw new Error('Invalid Jalaali year ' + jy)

  // Find the limiting years for the Jalaali year jy.
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i]
    jump = jm - jp
    if (jy < jm)
      break
    leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4)
    jp = jm
  }
  n = jy - jp

  // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.
  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4)
  if (mod(jump, 33) === 4 && jump - n === 4)
    leapJ += 1

  // And the same in the Gregorian calendar (until the year gy).
  leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150

  // Determine the Gregorian date of Farvardin the 1st.
  march = 20 + leapJ - leapG

  // return with gy and march when we don't need leap
  if (withoutLeap) return { gy: gy, march: march };


  // Find how many years have passed since the last leap year.
  if (jump - n < 6)
    n = n - jump + div(jump + 4, 33) * 33
  leap = mod(mod(n + 1, 33) - 1, 4)
  if (leap === -1) {
    leap = 4
  }  

  return  { leap: leap
          , gy: gy
          , march: march
          }
}

/*
  Converts a date of the Jalaali calendar to the Julian Day number.

  @param jy Jalaali year (1 to 3100)
  @param jm Jalaali month (1 to 12)
  @param jd Jalaali day (1 to 29/31)
  @return Julian Day number
*/
function j2d(jy, jm, jd) {
  var r = jalCal(jy, true)
  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1
}

/*
  Converts the Julian Day number to a date in the Jalaali calendar.

  @param jdn Julian Day number
  @return
    jy: Jalaali year (1 to 3100)
    jm: Jalaali month (1 to 12)
    jd: Jalaali day (1 to 29/31)
*/
function d2j(jdn) {
  var gy = d2g(jdn).gy // Calculate Gregorian year (gy).
    , jy = gy - 621
    , r = jalCal(jy, false)
    , jdn1f = g2d(gy, 3, r.march)
    , jd
    , jm
    , k

  // Find number of days that passed since 1 Farvardin.
  k = jdn - jdn1f
  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div(k, 31)
      jd = mod(k, 31) + 1
      return  { jy: jy
              , jm: jm
              , jd: jd
              }
    } else {
      // The remaining months.
      k -= 186
    }
  } else {
    // Previous Jalaali year.
    jy -= 1
    k += 179
    if (r.leap === 1)
      k += 1
  }
  jm = 7 + div(k, 30)
  jd = mod(k, 30) + 1
  return  { jy: jy
          , jm: jm
          , jd: jd
          }
}

/*
  Calculates the Julian Day number from Gregorian or Julian
  calendar dates. This integer number corresponds to the noon of
  the date (i.e. 12 hours of Universal Time).
  The procedure was tested to be good since 1 March, -100100 (of both
  calendars) up to a few million years into the future.

  @param gy Calendar year (years BC numbered 0, -1, -2, ...)
  @param gm Calendar month (1 to 12)
  @param gd Calendar day of the month (1 to 28/29/30/31)
  @return Julian Day number
*/
function g2d(gy, gm, gd) {
  var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4)
      + div(153 * mod(gm + 9, 12) + 2, 5)
      + gd - 34840408
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752
  return d
}

/*
  Calculates Gregorian and Julian calendar dates from the Julian Day number
  (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
  calendars) to some millions years ahead of the present.

  @param jdn Julian Day number
  @return
    gy: Calendar year (years BC numbered 0, -1, -2, ...)
    gm: Calendar month (1 to 12)
    gd: Calendar day of the month M (1 to 28/29/30/31)
*/
function d2g(jdn) {
  var j
    , i
    , gd
    , gm
    , gy
  j = 4 * jdn + 139361631
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908
  i = div(mod(j, 1461), 4) * 5 + 308
  gd = div(mod(i, 153), 5) + 1
  gm = mod(div(i, 153), 12) + 1
  gy = div(j, 1461) - 100100 + div(8 - gm, 6)
  return  { gy: gy
          , gm: gm
          , gd: gd
          }
}

/*
  Utility helper functions.
*/

function div(a, b) {
  return ~~(a / b)
}

function mod(a, b) {
  return a - ~~(a / b) * b
}

},{}],68:[function(require,module,exports){
// moment-hijri.js
// author: Suhail Alkowaileet
// This is a modified version of moment-jalaali by Behrang Noruzi Niya
// license: MIT

'use strict';

/************************************
    Expose Moment Hijri
************************************/
(function (root, factory) {
	/* global define */
	if (typeof define === 'function' && define.amd) {
		define(['moment'], function (moment) {
			root.moment = factory(moment)
			return root.moment
		})
	} else if (typeof exports === 'object') {
		module.exports = factory(require('moment'))
	} else {
		root.moment = factory(root.moment)
	}
})(this, function (moment) { // jshint ignore:line

	if (moment == null) {
		throw new Error('Cannot find moment')
	}

	/************************************
      Constants
  ************************************/

	var ummalqura = {
		ummalquraData: [28607, 28636, 28665, 28695, 28724, 28754, 28783, 28813, 28843, 28872, 28901, 28931, 28960, 28990, 29019, 29049, 29078, 29108, 29137, 29167,
                      29196, 29226, 29255, 29285, 29315, 29345, 29375, 29404, 29434, 29463, 29492, 29522, 29551, 29580, 29610, 29640, 29669, 29699, 29729, 29759,
                      29788, 29818, 29847, 29876, 29906, 29935, 29964, 29994, 30023, 30053, 30082, 30112, 30141, 30171, 30200, 30230, 30259, 30289, 30318, 30348,
                      30378, 30408, 30437, 30467, 30496, 30526, 30555, 30585, 30614, 30644, 30673, 30703, 30732, 30762, 30791, 30821, 30850, 30880, 30909, 30939,
                      30968, 30998, 31027, 31057, 31086, 31116, 31145, 31175, 31204, 31234, 31263, 31293, 31322, 31352, 31381, 31411, 31441, 31471, 31500, 31530,
                      31559, 31589, 31618, 31648, 31676, 31706, 31736, 31766, 31795, 31825, 31854, 31884, 31913, 31943, 31972, 32002, 32031, 32061, 32090, 32120,
                      32150, 32180, 32209, 32239, 32268, 32298, 32327, 32357, 32386, 32416, 32445, 32475, 32504, 32534, 32563, 32593, 32622, 32652, 32681, 32711,
                      32740, 32770, 32799, 32829, 32858, 32888, 32917, 32947, 32976, 33006, 33035, 33065, 33094, 33124, 33153, 33183, 33213, 33243, 33272, 33302,
                      33331, 33361, 33390, 33420, 33450, 33479, 33509, 33539, 33568, 33598, 33627, 33657, 33686, 33716, 33745, 33775, 33804, 33834, 33863, 33893,
                      33922, 33952, 33981, 34011, 34040, 34069, 34099, 34128, 34158, 34187, 34217, 34247, 34277, 34306, 34336, 34365, 34395, 34424, 34454, 34483,
                      34512, 34542, 34571, 34601, 34631, 34660, 34690, 34719, 34749, 34778, 34808, 34837, 34867, 34896, 34926, 34955, 34985, 35015, 35044, 35074,
                      35103, 35133, 35162, 35192, 35222, 35251, 35280, 35310, 35340, 35370, 35399, 35429, 35458, 35488, 35517, 35547, 35576, 35605, 35635, 35665,
                      35694, 35723, 35753, 35782, 35811, 35841, 35871, 35901, 35930, 35960, 35989, 36019, 36048, 36078, 36107, 36136, 36166, 36195, 36225, 36254,
                      36284, 36314, 36343, 36373, 36403, 36433, 36462, 36492, 36521, 36551, 36580, 36610, 36639, 36669, 36698, 36728, 36757, 36786, 36816, 36845,
                      36875, 36904, 36934, 36963, 36993, 37022, 37052, 37081, 37111, 37141, 37170, 37200, 37229, 37259, 37288, 37318, 37347, 37377, 37406, 37436,
                      37465, 37495, 37524, 37554, 37584, 37613, 37643, 37672, 37701, 37731, 37760, 37790, 37819, 37849, 37878, 37908, 37938, 37967, 37997, 38027,
                      38056, 38085, 38115, 38144, 38174, 38203, 38233, 38262, 38292, 38322, 38351, 38381, 38410, 38440, 38469, 38499, 38528, 38558, 38587, 38617,
                      38646, 38676, 38705, 38735, 38764, 38794, 38823, 38853, 38882, 38912, 38941, 38971, 39001, 39030, 39059, 39089, 39118, 39148, 39178, 39208,
                      39237, 39267, 39297, 39326, 39355, 39385, 39414, 39444, 39473, 39503, 39532, 39562, 39592, 39621, 39650, 39680, 39709, 39739, 39768, 39798,
                      39827, 39857, 39886, 39916, 39946, 39975, 40005, 40035, 40064, 40094, 40123, 40153, 40182, 40212, 40241, 40271, 40300, 40330, 40359, 40389,
                      40418, 40448, 40477, 40507, 40536, 40566, 40595, 40625, 40655, 40685, 40714, 40744, 40773, 40803, 40832, 40862, 40892, 40921, 40951, 40980,
                      41009, 41039, 41068, 41098, 41127, 41157, 41186, 41216, 41245, 41275, 41304, 41334, 41364, 41393, 41422, 41452, 41481, 41511, 41540, 41570,
                      41599, 41629, 41658, 41688, 41718, 41748, 41777, 41807, 41836, 41865, 41894, 41924, 41953, 41983, 42012, 42042, 42072, 42102, 42131, 42161,
                      42190, 42220, 42249, 42279, 42308, 42337, 42367, 42397, 42426, 42456, 42485, 42515, 42545, 42574, 42604, 42633, 42662, 42692, 42721, 42751,
                      42780, 42810, 42839, 42869, 42899, 42929, 42958, 42988, 43017, 43046, 43076, 43105, 43135, 43164, 43194, 43223, 43253, 43283, 43312, 43342,
                      43371, 43401, 43430, 43460, 43489, 43519, 43548, 43578, 43607, 43637, 43666, 43696, 43726, 43755, 43785, 43814, 43844, 43873, 43903, 43932,
                      43962, 43991, 44021, 44050, 44080, 44109, 44139, 44169, 44198, 44228, 44258, 44287, 44317, 44346, 44375, 44405, 44434, 44464, 44493, 44523,
                      44553, 44582, 44612, 44641, 44671, 44700, 44730, 44759, 44788, 44818, 44847, 44877, 44906, 44936, 44966, 44996, 45025, 45055, 45084, 45114,
                      45143, 45172, 45202, 45231, 45261, 45290, 45320, 45350, 45380, 45409, 45439, 45468, 45498, 45527, 45556, 45586, 45615, 45644, 45674, 45704,
                      45733, 45763, 45793, 45823, 45852, 45882, 45911, 45940, 45970, 45999, 46028, 46058, 46088, 46117, 46147, 46177, 46206, 46236, 46265, 46295,
                      46324, 46354, 46383, 46413, 46442, 46472, 46501, 46531, 46560, 46590, 46620, 46649, 46679, 46708, 46738, 46767, 46797, 46826, 46856, 46885,
                      46915, 46944, 46974, 47003, 47033, 47063, 47092, 47122, 47151, 47181, 47210, 47240, 47269, 47298, 47328, 47357, 47387, 47417, 47446, 47476,
                      47506, 47535, 47565, 47594, 47624, 47653, 47682, 47712, 47741, 47771, 47800, 47830, 47860, 47890, 47919, 47949, 47978, 48008, 48037, 48066,
                      48096, 48125, 48155, 48184, 48214, 48244, 48273, 48303, 48333, 48362, 48392, 48421, 48450, 48480, 48509, 48538, 48568, 48598, 48627, 48657,
                      48687, 48717, 48746, 48776, 48805, 48834, 48864, 48893, 48922, 48952, 48982, 49011, 49041, 49071, 49100, 49130, 49160, 49189, 49218, 49248,
                      49277, 49306, 49336, 49365, 49395, 49425, 49455, 49484, 49514, 49543, 49573, 49602, 49632, 49661, 49690, 49720, 49749, 49779, 49809, 49838,
                      49868, 49898, 49927, 49957, 49986, 50016, 50045, 50075, 50104, 50133, 50163, 50192, 50222, 50252, 50281, 50311, 50340, 50370, 50400, 50429,
                      50459, 50488, 50518, 50547, 50576, 50606, 50635, 50665, 50694, 50724, 50754, 50784, 50813, 50843, 50872, 50902, 50931, 50960, 50990, 51019,
                      51049, 51078, 51108, 51138, 51167, 51197, 51227, 51256, 51286, 51315, 51345, 51374, 51403, 51433, 51462, 51492, 51522, 51552, 51582, 51611,
                      51641, 51670, 51699, 51729, 51758, 51787, 51816, 51846, 51876, 51906, 51936, 51965, 51995, 52025, 52054, 52083, 52113, 52142, 52171, 52200,
                      52230, 52260, 52290, 52319, 52349, 52379, 52408, 52438, 52467, 52497, 52526, 52555, 52585, 52614, 52644, 52673, 52703, 52733, 52762, 52792,
                      52822, 52851, 52881, 52910, 52939, 52969, 52998, 53028, 53057, 53087, 53116, 53146, 53176, 53205, 53235, 53264, 53294, 53324, 53353, 53383,
                      53412, 53441, 53471, 53500, 53530, 53559, 53589, 53619, 53648, 53678, 53708, 53737, 53767, 53796, 53825, 53855, 53884, 53913, 53943, 53973,
                      54003, 54032, 54062, 54092, 54121, 54151, 54180, 54209, 54239, 54268, 54297, 54327, 54357, 54387, 54416, 54446, 54476, 54505, 54535, 54564,
                      54593, 54623, 54652, 54681, 54711, 54741, 54770, 54800, 54830, 54859, 54889, 54919, 54948, 54977, 55007, 55036, 55066, 55095, 55125, 55154,
                      55184, 55213, 55243, 55273, 55302, 55332, 55361, 55391, 55420, 55450, 55479, 55508, 55538, 55567, 55597, 55627, 55657, 55686, 55716, 55745,
                      55775, 55804, 55834, 55863, 55892, 55922, 55951, 55981, 56011, 56040, 56070, 56100, 56129, 56159, 56188, 56218, 56247, 56276, 56306, 56335,
                      56365, 56394, 56424, 56454, 56483, 56513, 56543, 56572, 56601, 56631, 56660, 56690, 56719, 56749, 56778, 56808, 56837, 56867, 56897, 56926,
                      56956, 56985, 57015, 57044, 57074, 57103, 57133, 57162, 57192, 57221, 57251, 57280, 57310, 57340, 57369, 57399, 57429, 57458, 57487, 57517,
                      57546, 57576, 57605, 57634, 57664, 57694, 57723, 57753, 57783, 57813, 57842, 57871, 57901, 57930, 57959, 57989, 58018, 58048, 58077, 58107,
                      58137, 58167, 58196, 58226, 58255, 58285, 58314, 58343, 58373, 58402, 58432, 58461, 58491, 58521, 58551, 58580, 58610, 58639, 58669, 58698,
                      58727, 58757, 58786, 58816, 58845, 58875, 58905, 58934, 58964, 58994, 59023, 59053, 59082, 59111, 59141, 59170, 59200, 59229, 59259, 59288,
                      59318, 59348, 59377, 59407, 59436, 59466, 59495, 59525, 59554, 59584, 59613, 59643, 59672, 59702, 59731, 59761, 59791, 59820, 59850, 59879,
                      59909, 59939, 59968, 59997, 60027, 60056, 60086, 60115, 60145, 60174, 60204, 60234, 60264, 60293, 60323, 60352, 60381, 60411, 60440, 60469,
                      60499, 60528, 60558, 60588, 60618, 60648, 60677, 60707, 60736, 60765, 60795, 60824, 60853, 60883, 60912, 60942, 60972, 61002, 61031, 61061,
                      61090, 61120, 61149, 61179, 61208, 61237, 61267, 61296, 61326, 61356, 61385, 61415, 61445, 61474, 61504, 61533, 61563, 61592, 61621, 61651,
                      61680, 61710, 61739, 61769, 61799, 61828, 61858, 61888, 61917, 61947, 61976, 62006, 62035, 62064, 62094, 62123, 62153, 62182, 62212, 62242,
                      62271, 62301, 62331, 62360, 62390, 62419, 62448, 62478, 62507, 62537, 62566, 62596, 62625, 62655, 62685, 62715, 62744, 62774, 62803, 62832,
                      62862, 62891, 62921, 62950, 62980, 63009, 63039, 63069, 63099, 63128, 63157, 63187, 63216, 63246, 63275, 63305, 63334, 63363, 63393, 63423,
                      63453, 63482, 63512, 63541, 63571, 63600, 63630, 63659, 63689, 63718, 63747, 63777, 63807, 63836, 63866, 63895, 63925, 63955, 63984, 64014,
                      64043, 64073, 64102, 64131, 64161, 64190, 64220, 64249, 64279, 64309, 64339, 64368, 64398, 64427, 64457, 64486, 64515, 64545, 64574, 64603,
                      64633, 64663, 64692, 64722, 64752, 64782, 64811, 64841, 64870, 64899, 64929, 64958, 64987, 65017, 65047, 65076, 65106, 65136, 65166, 65195,
                      65225, 65254, 65283, 65313, 65342, 65371, 65401, 65431, 65460, 65490, 65520, 65549, 65579, 65608, 65638, 65667, 65697, 65726, 65755, 65785,
                      65815, 65844, 65874, 65903, 65933, 65963, 65992, 66022, 66051, 66081, 66110, 66140, 66169, 66199, 66228, 66258, 66287, 66317, 66346, 66376,
                      66405, 66435, 66465, 66494, 66524, 66553, 66583, 66612, 66641, 66671, 66700, 66730, 66760, 66789, 66819, 66849, 66878, 66908, 66937, 66967,
                      66996, 67025, 67055, 67084, 67114, 67143, 67173, 67203, 67233, 67262, 67292, 67321, 67351, 67380, 67409, 67439, 67468, 67497, 67527, 67557,
                      67587, 67617, 67646, 67676, 67705, 67735, 67764, 67793, 67823, 67852, 67882, 67911, 67941, 67971, 68000, 68030, 68060, 68089, 68119, 68148,
                      68177, 68207, 68236, 68266, 68295, 68325, 68354, 68384, 68414, 68443, 68473, 68502, 68532, 68561, 68591, 68620, 68650, 68679, 68708, 68738,
                      68768, 68797, 68827, 68857, 68886, 68916, 68946, 68975, 69004, 69034, 69063, 69092, 69122, 69152, 69181, 69211, 69240, 69270, 69300, 69330,
                      69359, 69388, 69418, 69447, 69476, 69506, 69535, 69565, 69595, 69624, 69654, 69684, 69713, 69743, 69772, 69802, 69831, 69861, 69890, 69919,
                      69949, 69978, 70008, 70038, 70067, 70097, 70126, 70156, 70186, 70215, 70245, 70274, 70303, 70333, 70362, 70392, 70421, 70451, 70481, 70510,
                      70540, 70570, 70599, 70629, 70658, 70687, 70717, 70746, 70776, 70805, 70835, 70864, 70894, 70924, 70954, 70983, 71013, 71042, 71071, 71101,
                      71130, 71159, 71189, 71218, 71248, 71278, 71308, 71337, 71367, 71397, 71426, 71455, 71485, 71514, 71543, 71573, 71602, 71632, 71662, 71691,
                      71721, 71751, 71781, 71810, 71839, 71869, 71898, 71927, 71957, 71986, 72016, 72046, 72075, 72105, 72135, 72164, 72194, 72223, 72253, 72282,
                      72311, 72341, 72370, 72400, 72429, 72459, 72489, 72518, 72548, 72577, 72607, 72637, 72666, 72695, 72725, 72754, 72784, 72813, 72843, 72872,
                      72902, 72931, 72961, 72991, 73020, 73050, 73080, 73109, 73139, 73168, 73197, 73227, 73256, 73286, 73315, 73345, 73375, 73404, 73434, 73464,
                      73493, 73523, 73552, 73581, 73611, 73640, 73669, 73699, 73729, 73758, 73788, 73818, 73848, 73877, 73907, 73936, 73965, 73995, 74024, 74053,
                      74083, 74113, 74142, 74172, 74202, 74231, 74261, 74291, 74320, 74349, 74379, 74408, 74437, 74467, 74497, 74526, 74556, 74586, 74615, 74645,
                      74675, 74704, 74733, 74763, 74792, 74822, 74851, 74881, 74910, 74940, 74969, 74999, 75029, 75058, 75088, 75117, 75147, 75176, 75206, 75235,
                      75264, 75294, 75323, 75353, 75383, 75412, 75442, 75472, 75501, 75531, 75560, 75590, 75619, 75648, 75678, 75707, 75737, 75766, 75796, 75826,
                      75856, 75885, 75915, 75944, 75974, 76003, 76032, 76062, 76091, 76121, 76150, 76180, 76210, 76239, 76269, 76299, 76328, 76358, 76387, 76416,
                      76446, 76475, 76505, 76534, 76564, 76593, 76623, 76653, 76682, 76712, 76741, 76771, 76801, 76830, 76859, 76889, 76918, 76948, 76977, 77007,
                      77036, 77066, 77096, 77125, 77155, 77185, 77214, 77243, 77273, 77302, 77332, 77361, 77390, 77420, 77450, 77479, 77509, 77539, 77569, 77598,
                      77627, 77657, 77686, 77715, 77745, 77774, 77804, 77833, 77863, 77893, 77923, 77952, 77982, 78011, 78041, 78070, 78099, 78129, 78158, 78188,
                      78217, 78247, 78277, 78307, 78336, 78366, 78395, 78425, 78454, 78483, 78513, 78542, 78572, 78601, 78631, 78661, 78690, 78720, 78750, 78779,
                      78808, 78838, 78867, 78897, 78926, 78956, 78985, 79015, 79044, 79074, 79104, 79133, 79163, 79192, 79222, 79251, 79281, 79310, 79340, 79369,
                      79399, 79428, 79458, 79487, 79517, 79546, 79576, 79606, 79635, 79665, 79695, 79724, 79753, 79783, 79812, 79841, 79871, 79900, 79930, 79960,
                      79990]
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?i(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?)|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,
		localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g

	, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{1,4}/, parseTokenSixDigits = /[+\-]?\d{1,6}/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+(\.?)|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, parseTokenT = /T/i, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/

	, unitAliases = {
		hd: 'idate',
		hm: 'imonth',
		hy: 'iyear'
	}

	, formatFunctions = {}

	, ordinalizeTokens = 'DDD w M D'.split(' '), paddedTokens = 'M D w'.split(' ')

	, formatTokenFunctions = {
		iM: function () {
			return this.iMonth() + 1
		},
		iMMM: function (format) {
			return this.localeData().iMonthsShort(this, format)
		},
		iMMMM: function (format) {
			return this.localeData().iMonths(this, format)
		},
		iD: function () {
			return this.iDate()
		},
		iDDD: function () {
			return this.iDayOfYear()
		},
		iw: function () {
			return this.iWeek()
		},
		iYY: function () {
			return leftZeroFill(this.iYear() % 100, 2)
		},
		iYYYY: function () {
			return leftZeroFill(this.iYear(), 4)
		},
		iYYYYY: function () {
			return leftZeroFill(this.iYear(), 5)
		},
		igg: function () {
			return leftZeroFill(this.iWeekYear() % 100, 2)
		},
		igggg: function () {
			return this.iWeekYear()
		},
		iggggg: function () {
			return leftZeroFill(this.iWeekYear(), 5)
		}
	}, i

	function padToken(func, count) {
		return function (a) {
			return leftZeroFill(func.call(this, a), count)
		}
	}

	function ordinalizeToken(func, period) {
		return function (a) {
			return this.localeData().ordinal(func.call(this, a), period)
		}
	}

	while (ordinalizeTokens.length) {
		i = ordinalizeTokens.pop()
		formatTokenFunctions['i' + i + 'o'] = ordinalizeToken(formatTokenFunctions['i' + i], i)
	}
	while (paddedTokens.length) {
		i = paddedTokens.pop()
		formatTokenFunctions['i' + i + i] = padToken(formatTokenFunctions['i' + i], 2)
	}
	formatTokenFunctions.iDDDD = padToken(formatTokenFunctions.iDDD, 3)

	/************************************
      Helpers
  ************************************/

	function extend(a, b) {
		var key
		for (key in b)
			if (b.hasOwnProperty(key))
				a[key] = b[key]
		return a
	}

	function leftZeroFill(number, targetLength) {
		var output = number + ''
		while (output.length < targetLength)
			output = '0' + output
		return output
	}

	function isArray(input) {
		return Object.prototype.toString.call(input) === '[object Array]'
	}

	function normalizeUnits(units) {
		return units ? unitAliases[units] || units.toLowerCase().replace(/(.)s$/, '$1') : units
	}

	function setDate(moment, year, month, date) {
		var utc = moment._isUTC ? 'UTC' : ''
		moment._d['set' + utc + 'FullYear'](year)
		moment._d['set' + utc + 'Month'](month)
		moment._d['set' + utc + 'Date'](date)
	}

	function objectCreate(parent) {
		function F() {}
		F.prototype = parent
		return new F()
	}

	function getPrototypeOf(object) {
		if (Object.getPrototypeOf)
			return Object.getPrototypeOf(object)
		else if (''.__proto__) // jshint ignore:line
			return object.__proto__ // jshint ignore:line
		else
			return object.constructor.prototype
	}

	/************************************
      Languages
  ************************************/
	extend(getPrototypeOf(moment.localeData()), {
		_iMonths: ['Muharram'
                , 'Safar'
                , 'Rabi\' al-Awwal'
                , 'Rabi\' al-Thani'
                , 'Jumada al-Ula'
                , 'Jumada al-Alkhirah'
                , 'Rajab'
                , 'Shaban'
                , 'Ramadhan'
                , 'Shawwal'
                , 'Thul-Qidah'
                , 'Thul-Hijjah'
                ],
		iMonths: function (m) {
			return this._iMonths[m.iMonth()]
		}

		,
		_iMonthsShort: ['Muh'
                      , 'Saf'
                      , 'Rab-I'
                      , 'Rab-II'
                      , 'Jum-I'
                      , 'Jum-II'
                      , 'Raj'
                      , 'Sha'
                      , 'Ram'
                      , 'Shw'
                      , 'Dhu-Q'
                      , 'Dhu-H'
                      ],
		iMonthsShort: function (m) {
			return this._iMonthsShort[m.iMonth()]
		}

		,
		iMonthsParse: function (monthName) {
			var i, mom, regex
			if (!this._iMonthsParse)
				this._iMonthsParse = []
			for (i = 0; i < 12; i += 1) {
				// Make the regex if we don't have it already.
				if (!this._iMonthsParse[i]) {
					mom = hMoment([2000, (2 + i) % 12, 25])
					regex = '^' + this.iMonths(mom, '') + '$|^' + this.iMonthsShort(mom, '') + '$'
					this._iMonthsParse[i] = new RegExp(regex.replace('.', ''), 'i')
				}
				// Test the regex.
				if (this._iMonthsParse[i].test(monthName))
					return i
			}
		}
	});
	var iMonthNames = {
		iMonths: '__ _ _ _ _____ _ '.split('_'),
		iMonthsShort: '__ _ _ _ _____ _ '.split('_')
	};

	// Default to the momentjs 2.12+ API
	if (typeof moment.updateLocale === 'function') {
		moment.updateLocale('ar-sa', iMonthNames);
	} else {
		var oldLocale = moment.locale();
		moment.defineLocale('ar-sa', iMonthNames);
		moment.locale(oldLocale);
	}

	/************************************
      Formatting
  ************************************/

	function makeFormatFunction(format) {
		var array = format.match(formattingTokens),
			length = array.length,
			i

		for (i = 0; i < length; i += 1)
			if (formatTokenFunctions[array[i]])
				array[i] = formatTokenFunctions[array[i]]

		return function (mom) {
			var output = ''
			for (i = 0; i < length; i += 1)
				output += array[i] instanceof Function ? '[' + array[i].call(mom, format) + ']' : array[i]
			return output
		}
	}

	/************************************
      Parsing
  ************************************/

	function getParseRegexForToken(token, config) {
		switch (token) {
		case 'iDDDD':
			return parseTokenThreeDigits
		case 'iYYYY':
			return parseTokenFourDigits
		case 'iYYYYY':
			return parseTokenSixDigits
		case 'iDDD':
			return parseTokenOneToThreeDigits
		case 'iMMM':
		case 'iMMMM':
			return parseTokenWord
		case 'iMM':
		case 'iDD':
		case 'iYY':
		case 'iM':
		case 'iD':
			return parseTokenOneOrTwoDigits
		case 'DDDD':
			return parseTokenThreeDigits
		case 'YYYY':
			return parseTokenFourDigits
		case 'YYYYY':
			return parseTokenSixDigits
		case 'S':
		case 'SS':
		case 'SSS':
		case 'DDD':
			return parseTokenOneToThreeDigits
		case 'MMM':
		case 'MMMM':
		case 'dd':
		case 'ddd':
		case 'dddd':
			return parseTokenWord
		case 'a':
		case 'A':
			return moment.localeData(config._l)._meridiemParse
		case 'X':
			return parseTokenTimestampMs
		case 'Z':
		case 'ZZ':
			return parseTokenTimezone
		case 'T':
			return parseTokenT
		case 'MM':
		case 'DD':
		case 'YY':
		case 'HH':
		case 'hh':
		case 'mm':
		case 'ss':
		case 'M':
		case 'D':
		case 'd':
		case 'H':
		case 'h':
		case 'm':
		case 's':
			return parseTokenOneOrTwoDigits
		default:
			return new RegExp(token.replace('\\', ''))
		}
	}

	function addTimeToArrayFromToken(token, input, config) {
		var a, datePartArray = config._a

		switch (token) {
		case 'iM':
		case 'iMM':
			datePartArray[1] = input == null ? 0 : ~~input - 1
			break
		case 'iMMM':
		case 'iMMMM':
			a = moment.localeData(config._l).iMonthsParse(input)
			if (a != null)
				datePartArray[1] = a
			else
				config._isValid = false
			break
		case 'iD':
		case 'iDD':
		case 'iDDD':
		case 'iDDDD':
			if (input != null)
				datePartArray[2] = ~~input
			break
		case 'iYY':
			datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400)
			break
		case 'iYYYY':
		case 'iYYYYY':
			datePartArray[0] = ~~input
		}
		if (input == null)
			config._isValid = false
	}

	function dateFromArray(config) {
		var g, h, hy = config._a[0],
			hm = config._a[1],
			hd = config._a[2]

		if ((hy == null) && (hm == null) && (hd == null))
			return [0, 0, 1]
		hy = hy || 0
		hm = hm || 0
		hd = hd || 1
		if (hd < 1 || hd > hMoment.iDaysInMonth(hy, hm))
			config._isValid = false
		g = toGregorian(hy, hm, hd)
		h = toHijri(g.gy, g.gm, g.gd)
		config._hDiff = 0
		if (~~h.hy !== hy)
			config._hDiff += 1
		if (~~h.hm !== hm)
			config._hDiff += 1
		if (~~h.hd !== hd)
			config._hDiff += 1
		return [g.gy, g.gm, g.gd]
	}

	function makeDateFromStringAndFormat(config) {
		var tokens = config._f.match(formattingTokens),
			string = config._i,
			len = tokens.length,
			i, token, parsedInput

		config._a = []

		for (i = 0; i < len; i += 1) {
			token = tokens[i]
			parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
			if (parsedInput)
				string = string.slice(string.indexOf(parsedInput) + parsedInput.length)
			if (formatTokenFunctions[token])
				addTimeToArrayFromToken(token, parsedInput, config)
		}
		if (string)
			config._il = string

		return dateFromArray(config)
	}

	function makeDateFromStringAndArray(config, utc) {
		var len = config._f.length
		, i
		, format
		, tempMoment
		, bestMoment
		, currentScore
		, scoreToBeat

		if (len === 0) {
			return makeMoment(new Date(NaN))
		}

		for (i = 0; i < len; i += 1) {
			format = config._f[i]
			currentScore = 0
			tempMoment = makeMoment(config._i, format, config._l, utc)

			if (!tempMoment.isValid()) continue

			currentScore += tempMoment._hDiff
			if (tempMoment._il)
				currentScore += tempMoment._il.length
			if (scoreToBeat == null || currentScore < scoreToBeat) {
				scoreToBeat = currentScore
				bestMoment = tempMoment
			}
		}

		return bestMoment
	}

	function removeParsedTokens(config) {
		var string = config._i,
			input = '',
			format = '',
			array = config._f.match(formattingTokens),
			len = array.length,
			i, match, parsed

		for (i = 0; i < len; i += 1) {
			match = array[i]
			parsed = (getParseRegexForToken(match, config).exec(string) || [])[0]
			if (parsed)
				string = string.slice(string.indexOf(parsed) + parsed.length)
			if (!(formatTokenFunctions[match] instanceof Function)) {
				format += match
				if (parsed)
					input += parsed
			}
		}
		config._i = input
		config._f = format
	}

	/************************************
      Week of Year
  ************************************/

	function iWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
		var end = firstDayOfWeekOfYear - firstDayOfWeek,
			daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
			adjustedMoment

		if (daysToDayOfWeek > end) {
			daysToDayOfWeek -= 7
		}
		if (daysToDayOfWeek < end - 7) {
			daysToDayOfWeek += 7
		}
		adjustedMoment = hMoment(mom).add(daysToDayOfWeek, 'd')
		return {
			week: Math.ceil(adjustedMoment.iDayOfYear() / 7),
			year: adjustedMoment.iYear()
		}
	}

	/************************************
      Top Level Functions
  ************************************/

	function makeMoment(input, format, lang, utc) {
		var config =
			{ _i: input
			, _f: format
			, _l: lang
			}
			, date
			, m
			, hm
		if (format) {
			if (isArray(format)) {
				return makeDateFromStringAndArray(config, utc)
			} else {
				date = makeDateFromStringAndFormat(config)
				removeParsedTokens(config)
				format = 'YYYY-MM-DD-' + config._f
				input = leftZeroFill(date[0], 4) + '-'
					+ leftZeroFill(date[1] + 1, 2) + '-'
					+ leftZeroFill(date[2], 2) + '-'
					+ config._i
			}
		}
		if (utc)
			m = moment.utc(input, format, lang)
		else
			m = moment(input, format, lang)
		if (config._isValid === false)
			m._isValid = false
		m._hDiff = config._hDiff || 0
		hm = objectCreate(hMoment.fn)
		extend(hm, m)
		return hm
	}

	function hMoment(input, format, lang) {
		return makeMoment(input, format, lang, false)
	}

	extend(hMoment, moment)
	hMoment.fn = objectCreate(moment.fn)

	hMoment.utc = function (input, format, lang) {
		return makeMoment(input, format, lang, true)
	}

	/************************************
      hMoment Prototype
  ************************************/

	hMoment.fn.format = function (format) {
		var i, replace, me = this

		if (format) {
			i = 5
			replace = function (input) {
				return me.localeData().longDateFormat(input) || input
			}
			while (i > 0 && localFormattingTokens.test(format)) {
				i -= 1
				format = format.replace(localFormattingTokens, replace)
			}
			if (!formatFunctions[format]) {
				formatFunctions[format] = makeFormatFunction(format)
			}
			format = formatFunctions[format](this)
		}
		return moment.fn.format.call(this, format)
	}

	hMoment.fn.iYear = function (input) {
		var lastDay, h, g
		if (typeof input === 'number') {
			h = toHijri(this.year(), this.month(), this.date())
			lastDay = Math.min(h.hd, hMoment.iDaysInMonth(input, h.hm))
			g = toGregorian(input, h.hm, lastDay)
			setDate(this, g.gy, g.gm, g.gd)
			//Workaround: sometimes moment wont set the date correctly if current day is the last in the month
			if (this.month() !== g.gm || this.date() !== g.gd || this.year() !== g.gy) {
				setDate(this, g.gy, g.gm, g.gd)
			}
			moment.updateOffset(this)
			return this
		} else {
			return toHijri(this.year(), this.month(), this.date()).hy
		}
	}

	hMoment.fn.iMonth = function (input) {
		var lastDay, h, g
		if (input != null) {
			if (typeof input === 'string') {
				input = this.localeData().iMonthsParse(input)
				if(input >= 0) {
					input -= 1
				} else {
					return this
				}
			}
			h = toHijri(this.year(), this.month(), this.date())
			lastDay = Math.min(h.hd, hMoment.iDaysInMonth(h.hy, input))
			this.iYear(h.hy + div(input, 12))
			input = mod(input, 12)
			if (input < 0) {
				input += 12
				this.iYear(this.iYear() - 1)
			}
			g = toGregorian(this.iYear(), input, lastDay)
			setDate(this, g.gy, g.gm, g.gd)
			//Workaround: sometimes moment wont set the date correctly if current day is the last in the month
			if (this.month() !== g.gm || this.date() !== g.gd || this.year() !== g.gy) {
				setDate(this, g.gy, g.gm, g.gd)
			}
			moment.updateOffset(this)
			return this
		} else {
			return toHijri(this.year(), this.month(), this.date()).hm
		}
	}

	hMoment.fn.iDate = function (input) {
		var h, g
		if (typeof input === 'number') {
			h = toHijri(this.year(), this.month(), this.date())
			g = toGregorian(h.hy, h.hm, input)
			setDate(this, g.gy, g.gm, g.gd)
			//Workaround: sometimes moment wont set the date correctly if current day is the last in the month
			if (this.month() !== g.gm || this.date() !== g.gd || this.year() !== g.gy) {
				setDate(this, g.gy, g.gm, g.gd)
			}
			moment.updateOffset(this)
			return this
		} else {
			return toHijri(this.year(), this.month(), this.date()).hd
		}
	}

	hMoment.fn.iDayOfYear = function (input) {
		var dayOfYear = Math.round((hMoment(this).startOf('day') - hMoment(this).startOf('iYear')) / 864e5) + 1
		return input == null ? dayOfYear : this.add(input - dayOfYear, 'd')
	}

	hMoment.fn.iDaysInMonth = function () {
		return parseInt(hMoment(this).endOf('iMonth').format('iDD'));
	}

	hMoment.fn.iWeek = function (input) {
		var week = iWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).week
		return input == null ? week : this.add( (input - week) * 7, 'd')
	}

	hMoment.fn.iWeekYear = function (input) {
		var year = iWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year
		return input == null ? year : this.add(input - year, 'y')
	}

	hMoment.fn.add = function (val, units) {
		var temp
		if (units !== null && !isNaN(+units)) {
			temp = val
			val = units
			units = temp
		}
		units = normalizeUnits(units)
		if (units === 'iyear') {
			this.iYear(this.iYear() + val)
		} else if (units === 'imonth') {
			this.iMonth(this.iMonth() + val)
		} else if (units === 'idate') {
			this.iDate(this.iDate() + val)
		}
		 else {
			moment.fn.add.call(this, val, units)
		}
		return this
	}

	hMoment.fn.subtract = function (val, units) {
		var temp
		if (units !== null && !isNaN(+units)) {
			temp = val
			val = units
			units = temp
		}
		units = normalizeUnits(units)
		if (units === 'iyear') {
			this.iYear(this.iYear() - val)
		} else if (units === 'imonth') {
			this.iMonth(this.iMonth() - val)
		} else if (units === 'idate') {
			this.iDate(this.iDate() - val)
		} else {
			moment.fn.subtract.call(this, val, units)
		}
		return this
	}

	hMoment.fn.startOf = function (units) {
		units = normalizeUnits(units)
		if (units === 'iyear' || units === 'imonth') {
			if (units === 'iyear') {
				this.iMonth(0)
			}
			this.iDate(1)
			this.hours(0)
			this.minutes(0)
			this.seconds(0)
			this.milliseconds(0)
			return this
		} else {
			return moment.fn.startOf.call(this, units)
		}
	}

	hMoment.fn.endOf = function (units) {
		units = normalizeUnits(units)
		if (units === undefined || units === 'milisecond') {
			return this
		}
		return this.startOf(units).add(1, (units === 'isoweek' ? 'week' : units)).subtract(1, 'milliseconds')
	}

	hMoment.fn.clone = function () {
		return hMoment(this)
	}

	hMoment.fn.iYears = hMoment.fn.iYear
	hMoment.fn.iMonths = hMoment.fn.iMonth
	hMoment.fn.iDates = hMoment.fn.iDate
	hMoment.fn.iWeeks = hMoment.fn.iWeek

	/************************************
      hMoment Statics
  ************************************/

	hMoment.iDaysInMonth = function (year, month) {
		var i = getNewMoonMJDNIndex(year, month + 1),
			daysInMonth = ummalqura.ummalquraData[i] - ummalqura.ummalquraData[i - 1]
		return daysInMonth
	}

	function toHijri(gy, gm, gd) {
		var h = d2h(g2d(gy, gm + 1, gd))
		h.hm -= 1
		return h
	}

	function toGregorian(hy, hm, hd) {
		var g = d2g(h2d(hy, hm + 1, hd))
		g.gm -= 1
		return g
	}

	hMoment.iConvert = {
		toHijri: toHijri,
		toGregorian: toGregorian
	}

	return hMoment

	/************************************
      Hijri Conversion
  ************************************/

	/*
    Utility helper functions.
  */

	function div(a, b) {
		return~~ (a / b)
	}

	function mod(a, b) {
		return a - ~~(a / b) * b
	}

	/*
    Converts a date of the Hijri calendar to the Julian Day number.

    @param hy Hijri year (1356 to 1500)
    @param hm Hijri month (1 to 12)
    @param hd Hijri day (1 to 29/30)
    @return Julian Day number
  */

	function h2d(hy, hm, hd) {
		var i = getNewMoonMJDNIndex(hy, hm),
			mjdn = hd + ummalqura.ummalquraData[i - 1] - 1,
			jdn = mjdn + 2400000;
		return jdn
	}

	/*
    Converts the Julian Day number to a date in the Hijri calendar.

    @param jdn Julian Day number
    @return
      hy: Hijri year (1356 to 1500)
      hm: Hijri month (1 to 12)
      hd: Hijri day (1 to 29/30)
  */

	function d2h(jdn) {
		var mjdn = jdn - 2400000,
			i = getNewMoonMJDNIndexByJDN(mjdn),
			totalMonths = i + 16260,
			cYears = Math.floor((totalMonths - 1) / 12),
			hy = cYears + 1,
			hm = totalMonths - 12 * cYears,
			hd = mjdn - ummalqura.ummalquraData[i - 1] + 1

		return {
			hy: hy,
			hm: hm,
			hd: hd
		}
	}

	/*
    Calculates the Julian Day number from Gregorian or Julian
    calendar dates. This integer number corresponds to the noon of
    the date (i.e. 12 hours of Universal Time).
    The procedure was tested to be good since 1 March, -100100 (of both
    calendars) up to a few million years into the future.

    @param gy Calendar year (years BC numbered 0, -1, -2, ...)
    @param gm Calendar month (1 to 12)
    @param gd Calendar day of the month (1 to 28/29/30/31)
    @return Julian Day number
  */

	function g2d(gy, gm, gd) {
		var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408
		d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752
		return d
	}

	/*
    Calculates Gregorian and Julian calendar dates from the Julian Day number
    (hdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
    calendars) to some millions years ahead of the present.

    @param jdn Julian Day number
    @return
      gy: Calendar year (years BC numbered 0, -1, -2, ...)
      gm: Calendar month (1 to 12)
      gd: Calendar day of the month M (1 to 28/29/30/31)
  */

	function d2g(jdn) {
		var j, i, gd, gm, gy
		j = 4 * jdn + 139361631
		j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908
		i = div(mod(j, 1461), 4) * 5 + 308
		gd = div(mod(i, 153), 5) + 1
		gm = mod(div(i, 153), 12) + 1
		gy = div(j, 1461) - 100100 + div(8 - gm, 6)
		return {
			gy: gy,
			gm: gm,
			gd: gd
		}
	}

	/*
    Returns the index of the modified Julian day number of the new moon
    by the given year and month

    @param hy: Hijri year (1356 to 1500)
    @param hm: Hijri month (1 to 12)
    @return
        i: the index of the new moon in modified Julian day number.
  */
	function getNewMoonMJDNIndex(hy, hm) {
		var cYears = hy - 1,
			totalMonths = (cYears * 12) + 1 + (hm - 1),
			i = totalMonths - 16260
		return i
	}

	/*
    Returns the nearest new moon

    @param jdn Julian Day number
    @return
      i: the index of a modified Julian day number.
  */
	function getNewMoonMJDNIndexByJDN(mjdn) {
		for (var i = 0; i < ummalqura.ummalquraData.length; i=i+1) {
			if (ummalqura.ummalquraData[i] > mjdn)
				return i
		}
	}

});

},{"moment":70}],69:[function(require,module,exports){

module.exports = jMoment

var moment = require('moment')
  , jalaali = require('jalaali-js')

/************************************
    Constants
************************************/

var formattingTokens = /(\[[^\[]*\])|(\\)?j(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?|)|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g
  , localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS?|LL?L?L?|l{1,4})/g

  , parseTokenOneOrTwoDigits = /\d\d?/
  , parseTokenOneToThreeDigits = /\d{1,3}/
  , parseTokenThreeDigits = /\d{3}/
  , parseTokenFourDigits = /\d{1,4}/
  , parseTokenSixDigits = /[+\-]?\d{1,6}/
  , parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i
  , parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i
  , parseTokenT = /T/i
  , parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/
  , symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
  }
  , numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  }


  , unitAliases =
    { jm: 'jmonth'
    , jmonths: 'jmonth'
    , jy: 'jyear'
    , jyears: 'jyear'
    }

  , formatFunctions = {}

  , ordinalizeTokens = 'DDD w M D'.split(' ')
  , paddedTokens = 'M D w'.split(' ')

  , formatTokenFunctions =
    { jM: function () {
        return this.jMonth() + 1
      }
    , jMMM: function (format) {
        return this.localeData().jMonthsShort(this, format)
      }
    , jMMMM: function (format) {
        return this.localeData().jMonths(this, format)
      }
    , jD: function () {
        return this.jDate()
      }
    , jDDD: function () {
        return this.jDayOfYear()
      }
    , jw: function () {
        return this.jWeek()
      }
    , jYY: function () {
        return leftZeroFill(this.jYear() % 100, 2)
      }
    , jYYYY: function () {
        return leftZeroFill(this.jYear(), 4)
      }
    , jYYYYY: function () {
        return leftZeroFill(this.jYear(), 5)
      }
    , jgg: function () {
        return leftZeroFill(this.jWeekYear() % 100, 2)
      }
    , jgggg: function () {
        return this.jWeekYear()
      }
    , jggggg: function () {
        return leftZeroFill(this.jWeekYear(), 5)
      }
    }

function padToken(func, count) {
  return function (a) {
    return leftZeroFill(func.call(this, a), count)
  }
}
function ordinalizeToken(func, period) {
  return function (a) {
    return this.localeData().ordinal(func.call(this, a), period)
  }
}

(function () {
  var i
  while (ordinalizeTokens.length) {
    i = ordinalizeTokens.pop()
    formatTokenFunctions['j' + i + 'o'] = ordinalizeToken(formatTokenFunctions['j' + i], i)
  }
  while (paddedTokens.length) {
    i = paddedTokens.pop()
    formatTokenFunctions['j' + i + i] = padToken(formatTokenFunctions['j' + i], 2)
  }
  formatTokenFunctions.jDDDD = padToken(formatTokenFunctions.jDDD, 3)
}())

/************************************
    Helpers
************************************/

function extend(a, b) {
  var key
  for (key in b)
    if (b.hasOwnProperty(key))
      a[key] = b[key]
  return a
}

function leftZeroFill(number, targetLength) {
  var output = number + ''
  while (output.length < targetLength)
    output = '0' + output
  return output
}

function isArray(input) {
  return Object.prototype.toString.call(input) === '[object Array]'
}

// function compareArrays(array1, array2) {
//   var len = Math.min(array1.length, array2.length)
//     , lengthDiff = Math.abs(array1.length - array2.length)
//     , diffs = 0
//     , i
//   for (i = 0; i < len; i += 1)
//     if (~~array1[i] !== ~~array2[i])
//       diffs += 1
//   return diffs + lengthDiff
// }

function normalizeUnits(units) {
  if (units) {
    var lowered = units.toLowerCase()
    units = unitAliases[lowered] || lowered
  }
  return units
}

function setDate(m, year, month, date) {
  var d = m._d
  if (m._isUTC) {
    /*eslint-disable new-cap*/
    m._d = new Date(Date.UTC(year, month, date,
        d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()))
    /*eslint-enable new-cap*/
  } else {
    m._d = new Date(year, month, date,
        d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds())
  }
}

function objectCreate(parent) {
  function F() {}
  F.prototype = parent
  return new F()
}

function getPrototypeOf(object) {
  if (Object.getPrototypeOf)
    return Object.getPrototypeOf(object)
  else if (''.__proto__)
    return object.__proto__
  else
    return object.constructor.prototype
}

/************************************
    Languages
************************************/
extend(getPrototypeOf(moment.localeData()),
  { _jMonths: [ 'Farvardin'
              , 'Ordibehesht'
              , 'Khordaad'
              , 'Tir'
              , 'Amordaad'
              , 'Shahrivar'
              , 'Mehr'
              , 'Aabaan'
              , 'Aazar'
              , 'Dey'
              , 'Bahman'
              , 'Esfand'
              ]
  , jMonths: function (m) {
      return this._jMonths[m.jMonth()]
    }

  , _jMonthsShort:  [ 'Far'
                    , 'Ord'
                    , 'Kho'
                    , 'Tir'
                    , 'Amo'
                    , 'Sha'
                    , 'Meh'
                    , 'Aab'
                    , 'Aaz'
                    , 'Dey'
                    , 'Bah'
                    , 'Esf'
                    ]
  , jMonthsShort: function (m) {
      return this._jMonthsShort[m.jMonth()]
    }

  , jMonthsParse: function (monthName) {
      var i
        , mom
        , regex
      if (!this._jMonthsParse)
        this._jMonthsParse = []
      for (i = 0; i < 12; i += 1) {
        // Make the regex if we don't have it already.
        if (!this._jMonthsParse[i]) {
          mom = jMoment([2000, (2 + i) % 12, 25])
          regex = '^' + this.jMonths(mom, '') + '|^' + this.jMonthsShort(mom, '')
          this._jMonthsParse[i] = new RegExp(regex.replace('.', ''), 'i')
        }
        // Test the regex.
        if (this._jMonthsParse[i].test(monthName))
          return i
      }
    }
  }
)

/************************************
    Formatting
************************************/

function makeFormatFunction(format) {
  var array = format.match(formattingTokens)
    , length = array.length
    , i

  for (i = 0; i < length; i += 1)
    if (formatTokenFunctions[array[i]])
      array[i] = formatTokenFunctions[array[i]]

  return function (mom) {
    var output = ''
    for (i = 0; i < length; i += 1)
      output += array[i] instanceof Function ? '[' + array[i].call(mom, format) + ']' : array[i]
    return output
  }
}

/************************************
    Parsing
************************************/

function getParseRegexForToken(token, config) {
  switch (token) {
  case 'jDDDD':
    return parseTokenThreeDigits
  case 'jYYYY':
    return parseTokenFourDigits
  case 'jYYYYY':
    return parseTokenSixDigits
  case 'jDDD':
    return parseTokenOneToThreeDigits
  case 'jMMM':
  case 'jMMMM':
    return parseTokenWord
  case 'jMM':
  case 'jDD':
  case 'jYY':
  case 'jM':
  case 'jD':
    return parseTokenOneOrTwoDigits
  case 'DDDD':
    return parseTokenThreeDigits
  case 'YYYY':
    return parseTokenFourDigits
  case 'YYYYY':
    return parseTokenSixDigits
  case 'S':
  case 'SS':
  case 'SSS':
  case 'DDD':
    return parseTokenOneToThreeDigits
  case 'MMM':
  case 'MMMM':
  case 'dd':
  case 'ddd':
  case 'dddd':
    return parseTokenWord
  case 'a':
  case 'A':
    return moment.localeData(config._l)._meridiemParse
  case 'X':
    return parseTokenTimestampMs
  case 'Z':
  case 'ZZ':
    return parseTokenTimezone
  case 'T':
    return parseTokenT
  case 'MM':
  case 'DD':
  case 'YY':
  case 'HH':
  case 'hh':
  case 'mm':
  case 'ss':
  case 'M':
  case 'D':
  case 'd':
  case 'H':
  case 'h':
  case 'm':
  case 's':
    return parseTokenOneOrTwoDigits
  default:
    return new RegExp(token.replace('\\', ''))
  }
}

function addTimeToArrayFromToken(token, input, config) {
  var a
    , datePartArray = config._a

  switch (token) {
  case 'jM':
  case 'jMM':
    datePartArray[1] = input == null ? 0 : ~~input - 1
    break
  case 'jMMM':
  case 'jMMMM':
    a = moment.localeData(config._l).jMonthsParse(input)
    if (a != null)
      datePartArray[1] = a
    else
      config._isValid = false
    break
  case 'jD':
  case 'jDD':
  case 'jDDD':
  case 'jDDDD':
    if (input != null)
      datePartArray[2] = ~~input
    break
  case 'jYY':
    datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400)
    break
  case 'jYYYY':
  case 'jYYYYY':
    datePartArray[0] = ~~input
  }
  if (input == null)
    config._isValid = false
}

function dateFromArray(config) {
  var g
    , j
    , jy = config._a[0]
    , jm = config._a[1]
    , jd = config._a[2]

  if ((jy == null) && (jm == null) && (jd == null))
    return [0, 0, 1]
  jy = jy != null ? jy : 0
  jm = jm != null ? jm : 0
  jd = jd != null ? jd : 1
  if (jd < 1 || jd > jMoment.jDaysInMonth(jy, jm) || jm < 0 || jm > 11)
    config._isValid = false
  g = toGregorian(jy, jm, jd)
  j = toJalaali(g.gy, g.gm, g.gd)
  config._jDiff = 0
  if (~~j.jy !== jy)
    config._jDiff += 1
  if (~~j.jm !== jm)
    config._jDiff += 1
  if (~~j.jd !== jd)
    config._jDiff += 1
  return [g.gy, g.gm, g.gd]
}

function makeDateFromStringAndFormat(config) {
  var tokens = config._f.match(formattingTokens)
    , string = config._i + ''
    , len = tokens.length
    , i
    , token
    , parsedInput

  config._a = []

  for (i = 0; i < len; i += 1) {
    token = tokens[i]
    parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0]
    if (parsedInput)
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length)
    if (formatTokenFunctions[token])
      addTimeToArrayFromToken(token, parsedInput, config)
  }
  if (string)
    config._il = string
  return dateFromArray(config)
}

function makeDateFromStringAndArray(config, utc) {
  var len = config._f.length
    , i
    , format
    , tempMoment
    , bestMoment
    , currentScore
    , scoreToBeat

  if (len === 0) {
    return makeMoment(new Date(NaN))
  }

  for (i = 0; i < len; i += 1) {
    format = config._f[i]
    currentScore = 0
    tempMoment = makeMoment(config._i, format, config._l, config._strict, utc)

    if (!tempMoment.isValid()) continue

    // currentScore = compareArrays(tempMoment._a, tempMoment.toArray())
    currentScore += tempMoment._jDiff
    if (tempMoment._il)
      currentScore += tempMoment._il.length
    if (scoreToBeat == null || currentScore < scoreToBeat) {
      scoreToBeat = currentScore
      bestMoment = tempMoment
    }
  }

  return bestMoment
}

function removeParsedTokens(config) {
  var string = config._i + ''
    , input = ''
    , format = ''
    , array = config._f.match(formattingTokens)
    , len = array.length
    , i
    , match
    , parsed

  for (i = 0; i < len; i += 1) {
    match = array[i]
    parsed = (getParseRegexForToken(match, config).exec(string) || [])[0]
    if (parsed)
      string = string.slice(string.indexOf(parsed) + parsed.length)
    if (!(formatTokenFunctions[match] instanceof Function)) {
      format += match
      if (parsed)
        input += parsed
    }
  }
  config._i = input
  config._f = format
}

/************************************
    Week of Year
************************************/

function jWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
  var end = firstDayOfWeekOfYear - firstDayOfWeek
    , daysToDayOfWeek = firstDayOfWeekOfYear - mom.day()
    , adjustedMoment

  if (daysToDayOfWeek > end) {
    daysToDayOfWeek -= 7
  }
  if (daysToDayOfWeek < end - 7) {
    daysToDayOfWeek += 7
  }
  adjustedMoment = jMoment(mom).add(daysToDayOfWeek, 'd')
  return  { week: Math.ceil(adjustedMoment.jDayOfYear() / 7)
          , year: adjustedMoment.jYear()
          }
}

/************************************
    Top Level Functions
************************************/

function makeMoment(input, format, lang, strict, utc) {
  if (typeof lang === 'boolean') {
    utc = strict
    strict = lang
    lang = undefined
  }

  if (format && typeof format === 'string')
    format = fixFormat(format, moment)

  var config =
      { _i: input
      , _f: format
      , _l: lang
      , _strict: strict
      , _isUTC: utc
      }
    , date
    , m
    , jm
    , origInput = input
    , origFormat = format
  if (format) {
    if (isArray(format)) {
      return makeDateFromStringAndArray(config, utc)
    } else {
      date = makeDateFromStringAndFormat(config)
      removeParsedTokens(config)
      format = 'YYYY-MM-DD-' + config._f
      input = leftZeroFill(date[0], 4) + '-'
            + leftZeroFill(date[1] + 1, 2) + '-'
            + leftZeroFill(date[2], 2) + '-'
            + config._i
    }
  }
  if (utc)
    m = moment.utc(input, format, lang, strict)
  else
    m = moment(input, format, lang, strict)
  if (config._isValid === false)
    m._isValid = false
  m._jDiff = config._jDiff || 0
  jm = objectCreate(jMoment.fn)
  extend(jm, m)
  if (strict && jm.isValid()) {
    jm._isValid = jm.format(origFormat) === origInput
  }
  return jm
}

function jMoment(input, format, lang, strict) {
  return makeMoment(input, format, lang, strict, false)
}

extend(jMoment, moment)
jMoment.fn = objectCreate(moment.fn)

jMoment.utc = function (input, format, lang, strict) {
  return makeMoment(input, format, lang, strict, true)
}

jMoment.unix = function (input) {
  return makeMoment(input * 1000)
}

/************************************
    jMoment Prototype
************************************/

function fixFormat(format, _moment) {
  var i = 5
  var replace = function (input) {
    return _moment.localeData().longDateFormat(input) || input
  }
  while (i > 0 && localFormattingTokens.test(format)) {
    i -= 1
    format = format.replace(localFormattingTokens, replace)
  }
  return format
}

jMoment.fn.format = function (format) {

  if (format) {
    format = fixFormat(format, this)

    if (!formatFunctions[format]) {
      formatFunctions[format] = makeFormatFunction(format)
    }
    format = formatFunctions[format](this)
  }
  return moment.fn.format.call(this, format)
}

jMoment.fn.jYear = function (input) {
  var lastDay
    , j
    , g
  if (typeof input === 'number') {
    j = toJalaali(this.year(), this.month(), this.date())
    lastDay = Math.min(j.jd, jMoment.jDaysInMonth(input, j.jm))
    g = toGregorian(input, j.jm, lastDay)
    setDate(this, g.gy, g.gm, g.gd)
    moment.updateOffset(this)
    return this
  } else {
    return toJalaali(this.year(), this.month(), this.date()).jy
  }
}

jMoment.fn.jMonth = function (input) {
  var lastDay
    , j
    , g
  if (input != null) {
    if (typeof input === 'string') {
      input = this.lang().jMonthsParse(input)
      if (typeof input !== 'number')
        return this
    }
    j = toJalaali(this.year(), this.month(), this.date())
    lastDay = Math.min(j.jd, jMoment.jDaysInMonth(j.jy, input))
    this.jYear(j.jy + div(input, 12))
    input = mod(input, 12)
    if (input < 0) {
      input += 12
      this.jYear(this.jYear() - 1)
    }
    g = toGregorian(this.jYear(), input, lastDay)
    setDate(this, g.gy, g.gm, g.gd)
    moment.updateOffset(this)
    return this
  } else {
    return toJalaali(this.year(), this.month(), this.date()).jm
  }
}

jMoment.fn.jDate = function (input) {
  var j
    , g
  if (typeof input === 'number') {
    j = toJalaali(this.year(), this.month(), this.date())
    g = toGregorian(j.jy, j.jm, input)
    setDate(this, g.gy, g.gm, g.gd)
    moment.updateOffset(this)
    return this
  } else {
    return toJalaali(this.year(), this.month(), this.date()).jd
  }
}

jMoment.fn.jDayOfYear = function (input) {
  var dayOfYear = Math.round((jMoment(this).startOf('day') - jMoment(this).startOf('jYear')) / 864e5) + 1
  return input == null ? dayOfYear : this.add(input - dayOfYear, 'd')
}

jMoment.fn.jWeek = function (input) {
  var week = jWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).week
  return input == null ? week : this.add((input - week) * 7, 'd')
}

jMoment.fn.jWeekYear = function (input) {
  var year = jWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year
  return input == null ? year : this.add(input - year, 'y')
}

jMoment.fn.add = function (val, units) {
  var temp
  if (units !== null && !isNaN(+units)) {
    temp = val
    val = units
    units = temp
  }
  units = normalizeUnits(units)
  if (units === 'jyear') {
    this.jYear(this.jYear() + val)
  } else if (units === 'jmonth') {
    this.jMonth(this.jMonth() + val)
  } else {
    moment.fn.add.call(this, val, units)
  }
  return this
}

jMoment.fn.subtract = function (val, units) {
  var temp
  if (units !== null && !isNaN(+units)) {
    temp = val
    val = units
    units = temp
  }
  units = normalizeUnits(units)
  if (units === 'jyear') {
    this.jYear(this.jYear() - val)
  } else if (units === 'jmonth') {
    this.jMonth(this.jMonth() - val)
  } else {
    moment.fn.subtract.call(this, val, units)
  }
  return this
}

jMoment.fn.startOf = function (units) {
  units = normalizeUnits(units)
  if (units === 'jyear' || units === 'jmonth') {
    if (units === 'jyear') {
      this.jMonth(0)
    }
    this.jDate(1)
    this.hours(0)
    this.minutes(0)
    this.seconds(0)
    this.milliseconds(0)
    return this
  } else {
    return moment.fn.startOf.call(this, units)
  }
}

jMoment.fn.endOf = function (units) {
  units = normalizeUnits(units)
  if (units === undefined || units === 'milisecond') {
    return this
  }
  return this.startOf(units).add(1, (units === 'isoweek' ? 'week' : units)).subtract(1, 'ms')
}

jMoment.fn.isSame = function (other, units) {
  units = normalizeUnits(units)
  if (units === 'jyear' || units === 'jmonth') {
    return moment.fn.isSame.call(this.startOf(units), other.startOf(units))
  }
  return moment.fn.isSame.call(this, other, units)
}

jMoment.fn.clone = function () {
  return jMoment(this)
}

jMoment.fn.jYears = jMoment.fn.jYear
jMoment.fn.jMonths = jMoment.fn.jMonth
jMoment.fn.jDates = jMoment.fn.jDate
jMoment.fn.jWeeks = jMoment.fn.jWeek

/************************************
    jMoment Statics
************************************/

jMoment.jDaysInMonth = function (year, month) {
  year += div(month, 12)
  month = mod(month, 12)
  if (month < 0) {
    month += 12
    year -= 1
  }
  if (month < 6) {
    return 31
  } else if (month < 11) {
    return 30
  } else if (jMoment.jIsLeapYear(year)) {
    return 30
  } else {
    return 29
  }
}

jMoment.jIsLeapYear = jalaali.isLeapJalaaliYear

jMoment.loadPersian = function (args) {
  var usePersianDigits =  args !== undefined && args.hasOwnProperty('usePersianDigits') ? args.usePersianDigits : false
  var dialect =  args !== undefined && args.hasOwnProperty('dialect') ? args.dialect : 'persian'
  moment.locale('fa')
  moment.updateLocale('fa'
  , { months: ('___________').split('_')
    , monthsShort: ('___________').split('_')
    , weekdays:
      {
        'persian': ('\u200c__\u200c__\u200c__').split('_'),
        'persian-modern': ('\u200c__\u200c__\u200c__').split('_')
      }[dialect]
    , weekdaysShort:
      {
        'persian': ('\u200c__\u200c__\u200c__').split('_'),
        'persian-modern': ('\u200c__\u200c__\u200c__').split('_')
      }[dialect]
    , weekdaysMin:
      {
        'persian': '______'.split('_'),
        'persian-modern': '______'.split('_')
      }[dialect]
    , longDateFormat:
      { LT: 'HH:mm'
      , L: 'jYYYY/jMM/jDD'
      , LL: 'jD jMMMM jYYYY'
      , LLL: 'jD jMMMM jYYYY LT'
      , LLLL: 'dddd jD jMMMM jYYYY LT'
      }
    , calendar:
      { sameDay: '[ ] LT'
      , nextDay: '[ ] LT'
      , nextWeek: 'dddd [] LT'
      , lastDay: '[ ] LT'
      , lastWeek: 'dddd [  ] LT'
      , sameElse: 'L'
      }
    , relativeTime:
      { future: ' %s'
      , past: '%s '
      , s: ' '
      , m: '1 '
      , mm: '%d '
      , h: '1 '
      , hh: '%d '
      , d: '1 '
      , dd: '%d '
      , M: '1 '
      , MM: '%d '
      , y: '1 '
      , yy: '%d '
      }
    , preparse: function (string) {
        if (usePersianDigits) {
          return string.replace(/[-]/g, function (match) {
            return numberMap[match]
          }).replace(//g, ',')
        }
        return string
    }
    , postformat: function (string) {
        if (usePersianDigits) {
          return string.replace(/\d/g, function (match) {
            return symbolMap[match]
          }).replace(/,/g, '')
        }
        return string
    }
    , ordinal: '%d'
    , week:
      { dow: 6 // Saturday is the first day of the week.
      , doy: 12 // The week that contains Jan 1st is the first week of the year.
      }
    , meridiem: function (hour) {
        return hour < 12 ? '.' : '.'
      }
    , jMonths:
      {
        'persian': ('___________').split('_'),
        'persian-modern': ('___________').split('_')
      }[dialect]
    , jMonthsShort:
      {
        'persian': '___________'.split('_'),
        'persian-modern': '___________'.split('_')
      }[dialect]
    }
  )
}

jMoment.jConvert =  { toJalaali: toJalaali
                    , toGregorian: toGregorian
                    }

/************************************
    Jalaali Conversion
************************************/

function toJalaali(gy, gm, gd) {
  var j = jalaali.toJalaali(gy, gm + 1, gd)
  j.jm -= 1
  return j
}

function toGregorian(jy, jm, jd) {
  var g = jalaali.toGregorian(jy, jm + 1, jd)
  g.gm -= 1
  return g
}

/*
  Utility helper functions.
*/

function div(a, b) {
  return ~~(a / b)
}

function mod(a, b) {
  return a - ~~(a / b) * b
}

},{"jalaali-js":67,"moment":70}],70:[function(require,module,exports){
//! moment.js
//! version : 2.29.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key;
                for (i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                    matched,
                    p1,
                    p2,
                    p3,
                    p4
                ) {
                    return p1 || p2 || p3 || p4;
                })
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
            '_'
        ),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
        input,
        array,
        config,
        token
    ) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.29.1';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));

},{}],71:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],72:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

function allSettled(arr) {
  var P = this;
  return new P(function(resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(
        new TypeError(
          typeof arr +
            ' ' +
            arr +
            ' is not iterable(cannot read property Symbol(Symbol.iterator))'
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(
            val,
            function(val) {
              res(i, val);
            },
            function(e) {
              args[i] = { status: 'rejected', reason: e };
              if (--remaining === 0) {
                resolve(args);
              }
            }
          );
          return;
        }
      }
      args[i] = { status: 'fulfilled', value: val };
      if (--remaining === 0) {
        resolve(args);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = finallyConstructor;

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.allSettled = allSettled;

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

module.exports = Promise;

}).call(this)}).call(this,require("timers").setImmediate)
},{"timers":74}],73:[function(require,module,exports){
!function(root, factory) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module unless amdModuleId is set
    define([], function() {
        return root.svg4everybody = factory();
    }) : "object" == typeof module && module.exports ? // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory() : root.svg4everybody = factory();
}(this, function() {
    /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
    function embed(parent, svg, target) {
        // if the target exists
        if (target) {
            // create a document fragment to hold the contents of the target
            var fragment = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
            // conditionally set the viewBox on the svg
            viewBox && svg.setAttribute("viewBox", viewBox);
            // copy the contents of the clone into the fragment
            for (// clone the target
            var clone = target.cloneNode(!0); clone.childNodes.length; ) {
                fragment.appendChild(clone.firstChild);
            }
            // append the fragment into the svg
            parent.appendChild(fragment);
        }
    }
    function loadreadystatechange(xhr) {
        // listen to changes in the request
        xhr.onreadystatechange = function() {
            // if the request is ready
            if (4 === xhr.readyState) {
                // get the cached html document
                var cachedDocument = xhr._cachedDocument;
                // ensure the cached html document based on the xhr response
                cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), 
                cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
                xhr._embeds.splice(0).map(function(item) {
                    // get the cached target
                    var target = xhr._cachedTarget[item.id];
                    // ensure the cached target
                    target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), 
                    // embed the target into the svg
                    embed(item.parent, item.svg, target);
                });
            }
        }, // test the ready state change immediately
        xhr.onreadystatechange();
    }
    function svg4everybody(rawopts) {
        function oninterval() {
            // while the index exists in the live <use> collection
            for (// get the cached <use> index
            var index = 0; index < uses.length; ) {
                // get the current <use>
                var use = uses[index], parent = use.parentNode, svg = getSVGAncestor(parent), src = use.getAttribute("xlink:href") || use.getAttribute("href");
                if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), 
                svg && src) {
                    if (polyfill) {
                        if (!opts.validate || opts.validate(src, svg, use)) {
                            // remove the <use> element
                            parent.removeChild(use);
                            // parse the src and get the url and id
                            var srcSplit = src.split("#"), url = srcSplit.shift(), id = srcSplit.join("#");
                            // if the link is external
                            if (url.length) {
                                // get the cached xhr request
                                var xhr = requests[url];
                                // ensure the xhr request exists
                                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), 
                                xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
                                xhr._embeds.push({
                                    parent: parent,
                                    svg: svg,
                                    id: id
                                }), // prepare the xhr ready state change event
                                loadreadystatechange(xhr);
                            } else {
                                // embed the local id into the svg
                                embed(parent, svg, document.getElementById(id));
                            }
                        } else {
                            // increase the index when the previous value was not "valid"
                            ++index, ++numberOfSvgUseElementsToBypass;
                        }
                    }
                } else {
                    // increase the index when the previous value was not "valid"
                    ++index;
                }
            }
            // continue the interval
            (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
        }
        var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/, edgeUA = /\bEdge\/.(\d+)\b/, inIframe = window.top !== window.self;
        polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
        // create xhr requests object
        var requests = {}, requestAnimationFrame = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use"), numberOfSvgUseElementsToBypass = 0;
        // conditionally start the interval if the polyfill is active
        polyfill && oninterval();
    }
    function getSVGAncestor(node) {
        for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {}
        return svg;
    }
    return svg4everybody;
});
},{}],74:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":71,"timers":74}],75:[function(require,module,exports){
module.exports={
	"icewarpapi": "/icewarpapi/"
}

},{}]},{},[15]);
